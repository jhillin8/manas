# Introduction ## What is Next.js? ## Main Features Feature | Description
Routing | A file-system based router built on top of Server Components that supports layouts, nested routing, loading states, error handling, and more.
Rendering | Client-side and Server-side Rendering with Client and Server Components. Further optimized with Static and Dynamic Rendering on the server with Next.js. Streaming on Edge and Node.js runtimes.
Data Fetching | Simplified data fetching with async/await in Server Components, and an extendedfetchAPI for request memoization, data caching and revalidation.
Styling | Support for your preferred styling methods, including CSS Modules, Tailwind CSS, and CSS-in-JS
Optimizations | Image, Fonts, and Script Optimizations to improve your application's Core Web Vitals and User Experience.
TypeScript | Improved support for TypeScript, with better type checking and more efficient compilation, as well as custom TypeScript Plugin and type checker. ```
fetch ## How to Use These Docs On the left side of the screen, you'll find the docs navbar. The pages of the docs are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your application. However, you can read them in any order or skip to the pages that apply to your use case. To get started, check out theInstallationguide. ## App Router vs Pages Router At the top of the sidebar, you'll notice a dropdown menu that allows you to switch between theApp Routerand thePages Routerfeatures. Since there are features that are unique to each directory, it's important to keep track of which tab is selected. The breadcrumbs at the top of the page will also indicate whether you're viewing App Router docs or Pages Router docs. ## Pre-Requisite Knowledge ## Accessibility For optimal accessibility when using a screen reader while reading the docs, we recommend using Firefox and NVDA, or Safari and VoiceOver. ## Join our Community ## Next Steps ### Installation
================================================================================

================================================================================

# Optimizations ## Built-in Components Built-in components abstract away the complexity of implementing common UI optimizations. These components are: • Images: Built on the native<img>element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.
• Link: Built on the native<a>tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.
• Scripts: Built on the native<script>tags. The Script Component gives you control over loading and execution of third-party scripts. ```
<img>
<a>
<script> ## Metadata ```
<head>
```• Config-based Metadata: Export astaticmetadataobjector a dynamicgenerateMetadatafunctionin alayout.jsorpage.jsfile.
• File-based Metadata: Add static or dynamically generated special files to route segments. ```
metadata
generateMetadata
layout.js
page.js
```
/public ## Analytics and Monitoring ### Images ### Videos ### Fonts ### Scripts ### Package Bundling ### Lazy Loading ### Analytics ### Instrumentation ### OpenTelemetry ### Third Party Libraries ### Memory Usage ### Local Development
================================================================================

================================================================================

# React Foundations ### Prerequisite knowledge ### System requirements Before you start this course, make sure you have the following installed: • Node.js 20.12.0 or later installed.
• Operating systems: macOS, Windows (including WSL), or Linux.
• VSCode or another text editor of your choice. ### Join the conversation ## Ready to get started? Now that you've been introduced to the course, let's dive in.
================================================================================

================================================================================

# Routing Fundamentals ### Layouts and Templates ### Linking and Navigating ### Error Handling ### Loading UI and Streaming ### Redirecting ### Route Groups ### Dynamic Routes ### Parallel Routes ### Intercepting Routes ### Route Handlers ### Middleware ### Internationalization
================================================================================

================================================================================

# Styling • CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.
• Global CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.
• Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes.
• Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins.
• CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling. Learn more about each approach by exploring their respective documentation: ### CSS ### Tailwind CSS ### Sass ### CSS-in-JS
================================================================================

================================================================================

# TypeScript ```
create-next-app
.ts
.tsx
next dev
next build
tsconfig.json
jsconfig.json
paths ## IDE Plugin You can enable the plugin in VS Code by: • Opening the command palette (Ctrl/⌘+Shift+P)
• Searching for "TypeScript: Select TypeScript Version"
• Selecting "Use Workspace Version" ```
Ctrl/⌘
Shift
```The TypeScript plugin can help with: • Warning if the invalid values forsegment config optionsare passed.
• Showing available options and in-context documentation.
• Ensuring theuse clientdirective is used correctly.
• Ensuring client hooks (likeuseState) are only used in Client Components. ```
use client
useState
```
fetch
app
Date
Map
Set
app
pages
```We're able to type the response data as you would expect with normal TypeScript. For example: ```
asyncfunctiongetData() {constres=awaitfetch('https://api.example.com/...')// The return value is *not* serialized// You can return Date, Map, Set, etc.returnres.json()}exportdefaultasyncfunctionPage() {constname=awaitgetData()return'...'}
```
next.config.ts
importtype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfig
CommonJS
next.config.js
// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfig ### Statically Typed Links ```
next/link
```To opt-into this feature,experimental.typedRoutesneed to be enabled and the project needs to be using TypeScript. ```
experimental.typedRoutes
importtype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{typedRoutes:true,},}exportdefaultnextConfig
.next/types
```
href
as Route
importtype{ Route }from'next';importLinkfrom'next/link'// No TypeScript errors if href is a valid route<Linkhref="/about"/><Linkhref="/blog/nextjs"/><Linkhref={`/blog/${slug}`} /><Linkhref={('/blog'+slug)asRoute} />// TypeScript errors if href is not a valid route<Linkhref="/aboot"/>
importtype{ Route }from'next'importLinkfrom'next/link'functionCard<Textendsstring>({ href }:{ href:Route<T>|URL}) {return(<Linkhref={href}><div>My Card</div></Link>)}
```How does it work? ```
.d.ts
.next
Link ### With Async Server Components To use anasyncServer Component with TypeScript, ensure you are using TypeScript5.1.3or higher and@types/react18.2.8or higher. ```
async
5.1.3
@types/react
18.2.8
```
'Promise<Element>' is not a valid JSX element ### Incremental type checking ```
v10.2.1 ### Disabling TypeScript errors in production If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. ```
ignoreBuildErrors
typescript
importtype{ NextConfig }from'next'constnextConfig:NextConfig={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfig

================================================================================

# Data Fetching ### Data Fetching and Caching ### Server Actions and Mutations ### Incremental Static Regeneration (ISR)
================================================================================

================================================================================

# Script Optimization ### Layout Scripts ```
next/script
importScriptfrom'next/script'exportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return(<><section>{children}</section><Scriptsrc="https://example.com/script.js"/></>)}
dashboard/page.js
dashboard/settings/page.js ### Application Scripts ```
importScriptfrom'next/script'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{children}</body><Scriptsrc="https://example.com/script.js"/></html>)}
```Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance. ### Strategy ```
strategy
```
• afterInteractive: (default) Load the script early but after some hydration on the page occurs.
• lazyOnload: Load the script later during browser idle time.
• worker: (experimental) Load the script in a web worker. ```
beforeInteractive
afterInteractive
lazyOnload
worker ### Offloading Scripts To A Web Worker (experimental) Warning:Theworkerstrategy is not yet stable and does not yet work with the App Router. Use with caution. Scripts that use theworkerstrategy are offloaded and executed in a web worker withPartytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code. ```
nextScriptWorkers
next.config.js
module.exports={experimental:{nextScriptWorkers:true,},}
next
npm run dev
yarn dev
npmrundev
```You'll see instructions like these: Please install Partytown by runningnpm install @builder.io/partytown ```
npm install @builder.io/partytown
```
strategy="worker"
importScriptfrom'next/script'exportdefaultfunctionHome() {return(<><Scriptsrc="https://example.com/script.js"strategy="worker"/></>)} ### Inline Scripts Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces: ```
<Scriptid="show-banner">{`document.getElementById('banner').classList.remove('hidden')`}</Script>

================================================================================

# App Router ## What we'll be building For this course, we'll build a financial dashboard that has: • A public home page.
• A login page.
• Dashboard pages that are protected by authentication.
• The ability for users to add, edit, and delete invoices. The dashboard will also have an accompanying database, which you'll set up ina later chapter. ## Overview Here's an overview of features you'll learn about in this course: • Styling: The different ways to style your application in Next.js.
• Optimizations: How to optimize images, links, and fonts.
• Routing: How to create nested layouts and pages using file-system routing.
• Data Fetching: How to set up a Postgres database on Vercel, and best practices for fetching and streaming.
• Search and Pagination: How to implement search and pagination using URL search params.
• Mutating Data:How to mutate data using React Server Actions, and revalidate the Next.js cache.
• Error Handling:How to handle general and404not found errors.
• Form Validation and Accessibility:How to do server-side form validation and tips for improving accessibility.
• Authentication: How to add authentication to your application usingNextAuth.jsand Middleware.
• Metadata: How to add metadata and prepare your application for social sharing. ```
404
NextAuth.js ## Prerequisite knowledge This course assumes you have a basic understanding of React and JavaScript. If you're new to React, we recommend going through ourReact Foundationscourse first to learn the fundamentals of React, such as components, props, state, and hooks, and newer features like Server Components and Suspense. ## System requirements Before you start this course, make sure your system meets the following requirements: • Node.js 18.18.0 or later installed.Download here.
• Operating systems: macOS, Windows (including WSL), or Linux. In addition, you'll also need aGitHub Accountand aVercel Account. ## Join the conversation If you have questions about this course or would like to provide feedback, you can ask our community onRedditorGitHub. ## Ready to get started? Now that you've been introduced to the course, let's dive in. 1: Getting Started
================================================================================

================================================================================

# How to set up a new Next.js project ## System requirements Before you begin, make sure your system meets the following requirements: • Node.js 18.18or later.
• macOS, Windows (including WSL), or Linux. ## Automatic installation ```
create-next-app
npxcreate-next-app@latest
```On installation, you'll see the following prompts: ```
What is your project named? my-appWould you like to use TypeScript? No / YesWould you like to use ESLint? No / YesWould you like to use Tailwind CSS? No / YesWould you like your code inside a `src/` directory? No / YesWould you like to use App Router? (recommended) No / YesWould you like to use Turbopack for `next dev`? No / YesWould you like to customize the import alias (`@/*` by default)? No / YesWhat import alias would you like configured? @/* ## Manual installation ```
npminstallnext@latestreact@latestreact-dom@latest
```
package.json
{"scripts":{"dev":"next dev","build":"next build","start":"next start","lint":"next lint"}}
```These scripts refer to the different stages of developing an application: • next dev: Starts the development server.
• next build: Builds the application for production.
• next start: Starts the production server.
• next lint: Runs ESLint. ```
next dev
next build
next start
next lint ### Create theappdirectory ```
app
```
layout.tsx
<html>
<body>
exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{children}</body></html>)}
```Create a home pageapp/page.tsxwith some initial content: ```
app/page.tsx
exportdefaultfunctionPage() {return<h1>Hello, Next.js!</h1>}
```
page.tsx
```Good to know: • If you forget to create the root layout, Next.js will automatically create this file when running the development server withnext dev.
• You can optionally use asrcdirectoryin the root of your project to separate your application's code from configuration files. ```
src ### Create thepublicfolder (optional) ```
public
```
public/profile.png
/profile.png
importImagefrom'next/image'exportdefaultfunctionPage() {return<Imagesrc="/profile.png"alt="Profile"width={100}height={100} />} ## Run the development server • Runnpm run devto start the development server.
• Visithttp://localhost:3000to view your application.
• Edit theapp/page.tsxfile and save it to see the updated result in your browser. ```
npm run dev
http://localhost:3000 ## Set up TypeScript Minimum TypeScript version:v4.5.2 ```
v4.5.2
.ts
.tsx
tsconfig.json ### IDE Plugin You can enable the plugin in VS Code by: • Opening the command palette (Ctrl/⌘+Shift+P)
• Searching for "TypeScript: Select TypeScript Version"
• Selecting "Use Workspace Version" ```
Ctrl/⌘
Shift
```See theTypeScript referencepage for more information. ## Set up ESLint ```
{"scripts":{"lint":"next lint"}}
```
npm run lint
npmrunlint
```You'll see a prompt like this: ? How would you like to configure ESLint? ❯ Strict (recommended)BaseCancel • Strict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.
• Base: Includes Next.js' base ESLint configuration.
• Cancel: Skip configuration. Select this option if you plan on setting up your own custom ESLint configuration. ```
Strict
Base
eslint
eslint-config-next
.eslintrc.json
```
"paths"
"baseUrl"
jsconfig.json
```These options allow you to alias project directories to absolute paths, making it easier and cleaner to import modules. For example: ```
// Beforeimport{ Button }from'../../../components/button'// Afterimport{ Button }from'@/components/button'
```
baseUrl
{"compilerOptions":{"baseUrl":"src/"}}
```In addition to configuring thebaseUrlpath, you can use the"paths"option to"alias"module paths. ```
"alias"
```
@/components/*
components/*
{"compilerOptions":{"baseUrl":"src/","paths":{"@/styles/*":["styles/*"],"@/components/*":["components/*"]}}}

================================================================================

# Rendering ## Fundamentals To start, it's helpful to be familiar with three foundational web concepts: • TheEnvironmentsyour application code can be executed in: the server and the client.
• TheRequest-Response Lifecyclethat's initiated when a user visits or interacts with your application.
• TheNetwork Boundarythat separates server and client code. ### Rendering Environments There are two environments where web applications can be rendered: the client and the server. • Theclientrefers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into a user interface.
• Theserverrefers to the computer in a data center that stores your application code, receives requests from a client, and sends back an appropriate response. However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is not always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment over the other. ### Request-Response Lifecycle Broadly speaking, all websites follow the sameRequest-Response Lifecycle: • User Action:The user interacts with a web application. This could be clicking a link, submitting a form, or typing a URL directly into the browser's address bar.
• Server:The server processes the request and responds with the appropriate resources. This process may take a couple of steps like routing, fetching data, etc.
• Client:The client parses the resources to render the user interface.
• User Action:Once the user interface is rendered, the user can interact with it, and the whole process starts again. ```
GET
POST

================================================================================

# App Router TheApp Routeris a file-system based router that uses React's latest features such asServer Components,Suspense, andServer Functions. ## Next Steps ### Installation
================================================================================

================================================================================

# Local Development ## Local dev vs. production ```
next dev
next build
next start ## Improving local dev performance ### 1. Check your computer's antivirus Antivirus software can slow down file access. Try adding your project folder to the antivirus exclusion list. While this is more common on Windows machines, we recommend this for any system with an antivirus tool installed. ### 2. Update Next.js and enable Turbopack ```
npminstallnext@latestnpmrundev--turbopack
```Learn more about Turbopack. See ourupgrade guidesand codemods for more information. ### 3. Check your imports The way you import code can greatly affect compilation and bundling time. Learn more aboutoptimizing package bundlingand explore tools likeDependency CruiserorMadge. ### Icon libraries Libraries like@material-ui/iconsorreact-iconscan import thousands of icons, even if you only use a few. Try to import only the icons you need: ```
@material-ui/icons
react-icons
// Instead of this:import{ Icon1,Icon2 }from'react-icons/md'// Do this:importIcon1from'react-icons/md/Icon1'importIcon2from'react-icons/md/Icon2'
```
• md(Material Design Icons)
• tb(tabler-icons)
• cg(cssgg) ```
pi
md
tb
cg
```Combined they will be tens of thousands of modules that the compiler has to handle, even if you only use a single import from each. ### Barrel files "Barrel files" are files that export many items from other files. They can slow down builds because the compiler has to parse them to find if there are side-effects in the module scope by using the import. ### Optimize package imports ```
next.config.js
module.exports={experimental:{optimizePackageImports:['package-name'],},}
```
content
nodemodules
```Tailwind CSS version 3.4.8 or newer will warn you about settings that might slow down your build. • Avoid scanning unnecessary files:module.exports={content:[// Better - only scans the 'src' folder'../../packages/ui/src/**/*.{js,ts,jsx,tsx}',],} In yourtailwind.config.js, be specific about which files to scan: ```
tailwind.config.js
module.exports={content:['./src/**/*.{js,ts,jsx,tsx}',// Good// This might be too broad// It will match `packages//node_modules` too// '../../packages//*.{js,ts,jsx,tsx}',],}
```
module.exports={content:[// Better - only scans the 'src' folder'../../packages/ui/src/**/*.{js,ts,jsx,tsx}',],} ### 5. Check custom webpack settings If you've added custom webpack settings, they might be slowing down compilation. Consider if you really need them for local development. You can optionally only include certain tools for production builds, or explore moving to Turbopack and usingloaders. ### 6. Optimize memory usage If your app is very large, it might need more memory. Learn more about optimizing memory usage. ### 7. Server Components and data fetching Changes to Server Components cause the entire page to re-render locally in order to show the new changes, which includes fetching new data for the component. The experimentalserverComponentsHmrCacheoption allows you to cachefetchresponses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls. ```
serverComponentsHmrCache
fetch
```Learn more about the experimental option. ## Tools for finding problems ### Detailed fetch logging Use this command to see more detailed information about what's happening during development: ```
nextdev--verbose ## Turbopack tracing Turbopack tracing is a tool that helps you understand the performance of your application during local development.
It provides detailed information about the time taken for each module to compile and how they are related. • Make sure you have the latest version of Next.js installed.
• Generate a Turbopack trace file:NEXTTURBOPACKTRACING=1npmrundev
• Navigate around your application or make edits to files to reproduce the problem.
• Stop the Next.js development server.
• A file calledtrace-turbopackwill be available in the.nextfolder.
• Once the trace server is running you can view the trace athttps://trace.nextjs.org/.
• By default the trace viewer will aggregate timings, in order to see each individual time you can switch from "Aggregated in order" to "Spans in order" at the top right of the viewer. Generate a Turbopack trace file: ```
NEXTTURBOPACKTRACING=1npmrundev
trace-turbopack
.next
next internal trace [path-to-file]
nextinternaltrace.next/trace-turbopack
```
trace
turbo-trace-server
nextinternalturbo-trace-server.next/trace-turbopack ## Still having problems? Share the trace file generated in theTurbopack Tracingsection and share it onGitHub DiscussionsorDiscord.
================================================================================

================================================================================

# Image Optimization • Image Component According toWeb Almanac, images account for a huge portion of the typical website’spage weightand can have a sizable impact on your website'sLCP performance. ```
<img>
```• Size Optimization:Automatically serve correctly sized images for each device, using modern image formats like WebP.
• Visual Stability:Preventlayout shiftautomatically when images are loading.
• Faster Page Loads:Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
• Asset Flexibility:On-demand image resizing, even for images stored on remote servers ```
next/image ## Usage ```
importImagefrom'next/image'
```
src ### Local Images To use a local image,importyour.jpg,.png, or.webpimage files. ```
import
.jpg
.png
.webp
width
height
importImagefrom'next/image'importprofilePicfrom'./me.png'exportdefaultfunctionPage() {return(<Imagesrc={profilePic}alt="Picture of the author"// width={500} automatically provided// height={500} automatically provided// blurDataURL="data:..." automatically provided// placeholder="blur" // Optional blur-up while loading/>)}
```Warning:Dynamicawait import()orrequire()arenotsupported. Theimportmust be static so it can be analyzed at build time. ```
await import()
require()
localPatterns
next.config.js
module.exports={images:{localPatterns:[{pathname:'/assets/images/',search:'',},],},} ### Remote Images To use a remote image, thesrcproperty should be a URL string. ```
blurDataURL
importImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc="https://s3.amazonaws.com/my-bucket/profile.png"alt="Picture of the author"width={500}height={500}/>)}
module.exports={images:{remotePatterns:[{protocol:'https',hostname:'s3.amazonaws.com',port:'',pathname:'/my-bucket/',search:'',},],},}
```
remotePatterns
loader ### Domains Learn more aboutremotePatternsconfiguration. ### Loaders Note that in theexample earlier, a partial URL ("/me.png") is provided for a local image. This is possible because of the loader architecture. ```
"/me.png"
```A loader is a function that generates the URLs for your image. It modifies the providedsrc, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automaticsrcsetgeneration, so that visitors to your site will be served an image that is the right size for their viewport. You can define a loader per-image with theloaderprop, or at the application level with theloaderFileconfiguration. ```
loaderFile ## Priority ```
priority
next dev
<Image>
```
importImagefrom'next/image'importprofilePicfrom'../public/me.png'exportdefaultfunctionPage() {return<Imagesrc={profilePic}alt="Picture of the author"priority/>} ## Image Sizing One of the ways that images most commonly hurt performance is throughlayout shift, where the image pushes other elements around on the page as it loads in. This performance problem is so annoying to users that it has its own Core Web Vital, calledCumulative Layout Shift. The way to avoid image-based layout shifts is toalways size your images. This allows the browser to reserve precisely enough space for the image before it loads. • Automatically, using astatic import
• Manually, by including awidthandheightproperty used to determine the image's aspect ratio.
• Implicitly, by usingfillwhich causes the image to expand to fill its parent element. What if I don't know the size of my images? If you are accessing images from a source without knowledge of the images' sizes, there are several things you can do: Usefill ```
fill
```Thefillprop allows your image to be sized by its parent element. Consider using CSS to give the image's parent element space on the page alongsizesprop to match any media query break points. You can also useobject-fitwithfill,contain, orcover, andobject-positionto define how the image should occupy that space. ```
sizes
object-fit
contain
cover
object-position
```
• When usingfill, the parent element must havedisplay: blockThis is the default for<div>elements but should be specified otherwise. ```
className
style
styled-jsx
```• In most cases, we recommend using theclassNameprop. This can be an importedCSS Module, aglobal stylesheet, etc.
• You can also use thestyleprop to assign inline styles.
• You cannot usestyled-jsxbecause it's scoped to the current component (unless you mark the style asglobal). ```
global
position: relative
```
display: block
```• This is the default for<div>elements but should be specified otherwise. ```
<div> ## Examples ### Responsive ```
importImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionResponsive() {return(<divstyle={{ display:'flex',flexDirection:'column'}}><Imagealt="Mountains"// Importing an image will// automatically set the width and heightsrc={mountains}sizes="100vw"// Make the image display full widthstyle={{width:'100%',height:'auto',}}/></div>)} ### Fill Container ```
importImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionFill() {return(<divstyle={{display:'grid',gridGap:'8px',gridTemplateColumns:'repeat(auto-fit, minmax(400px, auto))',}}><divstyle={{ position:'relative',height:'400px'}}><Imagealt="Mountains"src={mountains}fillsizes="(min-width: 808px) 50vw, 100vw"style={{objectFit:'cover',// cover, contain, none}}/></div>{/* And more images in the grid... */}</div>)} ### Background Image ```
importImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionBackground() {return(<Imagealt="Mountains"src={mountains}placeholder="blur"quality={100}fillsizes="100vw"style={{objectFit:'cover',}}/>)}
```
================================================================================

================================================================================

# Third Party Libraries ```
@next/third-parties ## Getting Started ```
npminstall@next/third-parties@latestnext@latest ## Google Third-Parties ```
@next/third-parties/google ### Google Tag Manager TheGoogleTagManagercomponent can be used to instantiate aGoogle Tag Managercontainer to your page. By default, it fetches the original inline script after hydration occurs on the page. ```
GoogleTagManager
```To load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID: ```
import{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><GoogleTagManagergtmId="GTM-XYZ"/><body>{children}</body></html>)}
```
import{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleTagManagergtmId="GTM-XYZ"/>} #### Sending Events ThesendGTMEventfunction can be used to track user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleTagManager />component must be
included in either a parent layout, page, or component, or directly in the same file. ```
sendGTMEvent
dataLayer
<GoogleTagManager />
'use client'import{ sendGTMEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGTMEvent({ event:'buttonClicked',value:'xyz'})}>Send Event</button></div>)}
```Refer to the Tag Managerdeveloper
documentationto learn about the
different variables and events that can be passed into the function. #### Server-side Tagging If you're using a server-side tag manager and servinggtm.jsscripts from your tagging server you can
usegtmScriptUrloption to specify the URL of the script. ```
gtm.js
gtmScriptUrl #### Options Options to pass to the Google Tag Manager. For a full list of options, read theGoogle Tag Manager
docs. Name | Type | Description
gtmId | Required | Your GTM container ID. Usually starts withGTM-.
gtmScriptUrl | Optional | GTM script URL. Defaults tohttps://www.googletagmanager.com/gtm.js.
dataLayer | Optional | Data layer object to instantiate the container with.
dataLayerName | Optional | Name of the data layer. Defaults todataLayer.
auth | Optional | Value of authentication parameter (gtmauth) for environment snippets.
preview | Optional | Value of preview parameter (gtmpreview) for environment snippets. ```
gtmId
GTM-
https://www.googletagmanager.com/gtm.js
dataLayerName
auth
gtmauth
preview
gtmpreview ### Google Analytics TheGoogleAnalyticscomponent can be used to includeGoogle Analytics
4to your page via the Google tag
(gtag.js). By default, it fetches the original scripts after hydration occurs on the page. ```
GoogleAnalytics
gtag.js
```
configure Google Analytics directly using it, rather than including Google Analytics as a separate
component. Refer to thedocumentationto learn more about the differences between Tag Manager andgtag.js. To load Google Analytics for all routes, include the component directly in your root layout and pass
in your measurement ID: ```
import{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{children}</body><GoogleAnalyticsgaId="G-XYZ"/></html>)}
```To load Google Analytics for a single route, include the component in your page file: ```
import{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleAnalyticsgaId="G-XYZ"/>} ThesendGAEventfunction can be used to measure user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleAnalytics />component must be
included in either a parent layout, page, or component, or directly in the same file. ```
sendGAEvent
<GoogleAnalytics />
'use client'import{ sendGAEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGAEvent('event','buttonClicked',{ value:'xyz'})}>Send Event</button></div>)}
```
documentationto learn
more about event parameters. #### Tracking Pageviews To ensure that client-side navigations are being measured correctly, verify that the“Enhanced
Measurement”property is
enabled in your Admin panel and the“Page changes based on browser history events”checkbox is
selected. Note: If you decide to manually send pageview events, make sure to disable the default
pageview measurement to avoid having duplicate data. Refer to the Google Analyticsdeveloper
documentationto learn more. Options to pass to the<GoogleAnalytics>component. ```
<GoogleAnalytics>

================================================================================

# OpenTelemetry We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
ReadOfficial OpenTelemetry docsfor more information about OpenTelemetry and how it works. This documentation uses terms likeSpan,TraceorExporterthroughout this doc, all of which can be found inthe OpenTelemetry Observability Primer. ```
getStaticProps ## Getting Started OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package@vercel/otelthat helps you get started quickly. ```
@vercel/otel ### Using@vercel/otel To get started, install the following packages: ```
npminstall@vercel/otel@opentelemetry/sdk-logs@opentelemetry/api-logs@opentelemetry/instrumentation
instrumentation.ts
.js
src
import{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel({ serviceName:'next-app'})}
```See the@vercel/oteldocumentationfor additional configuration options. Good to know: • Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.
• If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.
• We have created a basicwith-opentelemetryexample that you can use. ```
instrumentation
app
pages
pageExtensions ### Manual OpenTelemetry configuration The@vercel/otelpackage provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually. Firstly you need to install OpenTelemetry packages: ```
npminstall@opentelemetry/sdk-node@opentelemetry/resources@opentelemetry/semantic-conventions@opentelemetry/sdk-trace-node@opentelemetry/exporter-trace-otlp-http
NodeSDK
process.env.NEXTRUNTIME === 'nodejs'
instrumentation.node.ts
exportasyncfunctionregister() {if(process.env.NEXTRUNTIME==='nodejs') {awaitimport('./instrumentation.node.ts')}}
import{ OTLPTraceExporter }from'@opentelemetry/exporter-trace-otlp-http'import{ Resource }from'@opentelemetry/resources'import{ NodeSDK }from'@opentelemetry/sdk-node'import{ SimpleSpanProcessor }from'@opentelemetry/sdk-trace-node'import{ ATTRSERVICENAME }from'@opentelemetry/semantic-conventions'constsdk=newNodeSDK({resource:newResource({[ATTRSERVICENAME]:'next-app',}),spanProcessor:newSimpleSpanProcessor(newOTLPTraceExporter()),})sdk.start()
```
We recommend using ourOpenTelemetry dev environment. If everything works well you should be able to see the root server span labeled asGET /requested/pathname.
All other spans from that particular trace will be nested under it. ```
GET /requested/pathname
NEXTOTELVERBOSE=1 ## Deployment ### Using OpenTelemetry Collector When you are deploying with OpenTelemetry Collector, you can use@vercel/otel.
It will work both on Vercel and when self-hosted. #### Deploying on Vercel We made sure that OpenTelemetry works out of the box on Vercel. FollowVercel documentationto connect your project to an observability provider. #### Self-hosting ### Custom Exporters OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with@vercel/otelormanual OpenTelemetry configuration. ## Custom Spans You can add a custom span withOpenTelemetry APIs. ```
npminstall@opentelemetry/api
```The following example demonstrates a function that fetches GitHub stars and adds a customfetchGithubStarsspan to track the fetch request's result: ```
fetchGithubStars
import{ trace }from'@opentelemetry/api'exportasyncfunctionfetchGithubStars() {returnawaittrace.getTracer('nextjs-example').startActiveSpan('fetchGithubStars',async(span)=>{try{returnawaitgetValue()}finally{span.end()}})}
```
You can start creating new spans, and they should be correctly added to the exported trace. ```
register ## Default Spans in Next.js ```
next
```• next.spanname- duplicates span name
• next.spantype- each span type has a unique identifier
• next.route- The route pattern of the request (e.g.,/[param]/user).
• next.rsc(true/false) - Whether the request is an RSC request, such as prefetch. ```
next.spanname
next.spantype
next.route
/[param]/user
next.rsc
next.page
```
• You can think about it as a route to a special file (likepage.ts,layout.ts,loading.tsand others)
• It can be used as a unique identifier only when paired withnext.routebecause/layoutcan be used to identify both/(groupA)/layout.tsand/(groupB)/layout.ts ```
page.ts
layout.ts
loading.ts
/layout
/(groupA)/layout.ts
/(groupB)/layout.ts ### [http.method] [next.route] • next.spantype:BaseServer.handleRequest ```
BaseServer.handleRequest
```Attributes: • Common HTTP attributeshttp.methodhttp.statuscode
• Server HTTP attributeshttp.routehttp.target • http.method
• http.statuscode • http.route
• http.target ### render route (app) [next.route] • next.spantype:AppRender.getBodyResult. ```
AppRender.getBodyResult
```
AppRender.fetch
```This span represents the fetch request executed in your code. • Common HTTP attributeshttp.method
• Client HTTP attributeshttp.urlnet.peer.namenet.peer.port(only if specified) • http.url
• net.peer.name
• net.peer.port(only if specified) ```
net.peer.port
NEXTOTELFETCHDISABLED=1 ### executing api route (app) [next.route] • next.spantype:AppRouteRouteHandlers.runHandler. ```
AppRouteRouteHandlers.runHandler
```
Render.getServerSideProps
```This span represents the execution ofgetServerSidePropsfor a specific route. ```
getServerSideProps ### getStaticProps [next.route] • next.spantype:Render.getStaticProps. ```
Render.getStaticProps
```
Render.renderDocument
```This span represents the process of rendering the document for a specific route. ### generateMetadata [next.page] • next.spantype:ResolveMetadata.generateMetadata. ```
ResolveMetadata.generateMetadata
```
NextNodeServer.findPageComponents
```This span represents the process of resolving page components for a specific page. ### resolve segment modules • next.spantype:NextNodeServer.getLayoutOrPageModule. ```
NextNodeServer.getLayoutOrPageModule
```
NextNodeServer.startResponse

================================================================================

# Building Your Application ### Routing ### Data Fetching ### Rendering ### Caching ### Styling ### Optimizing ### Configuring ### Testing
================================================================================

================================================================================

# Instrumentation Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production. ## Convention To set up instrumentation, createinstrumentation.ts|jsfile in theroot directoryof your project (or inside thesrcfolder if using one). ```
instrumentation.ts|js
src
register
import{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel('next-app')}
```Good to know: • Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.
• If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match. ```
instrumentation
app
pages
pageExtensions ## Examples ### Importing files with side effects Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared. We recommend importing files using JavaScriptimportsyntax within yourregisterfunction. The following example demonstrates a basic usage ofimportin aregisterfunction: ```
import
exportasyncfunctionregister() {awaitimport('package-with-side-effect')}
```
NEXTRUNTIME
exportasyncfunctionregister() {if(process.env.NEXTRUNTIME==='nodejs') {awaitimport('./instrumentation-node')}if(process.env.NEXT_RUNTIME==='edge') {awaitimport('./instrumentation-edge')}} ## Learn more about Instrumentation ### instrumentation.js
================================================================================

================================================================================

# Video Optimization ## Using<video>and<iframe> ```
<video>
<iframe>
```Videos can be embedded on the page using the HTML<video>tag for direct video files and<iframe>for external platform-hosted videos. The HTML<video>tag can embed self-hosted or directly served video content, allowing full control over the playback and appearance. ```
exportfunctionVideo() {return(<videowidth="320"height="240"controlspreload="none"><sourcesrc="/path/to/video.mp4"type="video/mp4"/><tracksrc="/path/to/captions.vtt"kind="subtitles"srcLang="en"label="English"/>Your browser does not support the video tag.</video>)} ### Common<video>tag attributes Attribute | Description | Example Value
src | Specifies the source of the video file. | <video src="/path/to/video.mp4" />
width | Sets the width of the video player. | <video width="320" />
height | Sets the height of the video player. | <video height="240" />
controls | If present, it displays the default set of playback controls. | <video controls />
autoPlay | Automatically starts playing the video when the page loads. Note: Autoplay policies vary across browsers. | <video autoPlay />
loop | Loops the video playback. | <video loop />
muted | Mutes the audio by default. Often used withautoPlay. | <video muted />
preload | Specifies how the video is preloaded. Values:none,metadata,auto. | <video preload="none" />
playsInline | Enables inline playback on iOS devices, often necessary for autoplay to work on iOS Safari. | <video playsInline /> ```
src
<video src="/path/to/video.mp4" />
width
<video width="320" />
height
<video height="240" />
controls
<video controls />
autoPlay
<video autoPlay />
loop
<video loop />
muted
<video muted />
preload
none
metadata
auto
<video preload="none" />
playsInline
<video playsInline />
```
• Subtitles or Captions:Include subtitles or captions for users who are deaf or hard of hearing. Utilize the<track>tag with your<video>elements to specify caption file sources. ```
<track> The HTML<iframe>tag allows you to embed videos from external platforms like YouTube or Vimeo. ```
exportdefaultfunctionPage() {return(<iframesrc="https://www.youtube.com/embed/19g66ezsKAg"allowFullScreen/>)} ### Common<iframe>tag attributes Attribute | Description | Example Value
src | The URL of the page to embed. | <iframe src="https://example.com" />
width | Sets the width of the iframe. | <iframe width="500" />
height | Sets the height of the iframe. | <iframe height="300" />
allowFullScreen | Allows the iframe content to be displayed in full-screen mode. | <iframe allowFullScreen />
sandbox | Enables an extra set of restrictions on the content within the iframe. | <iframe sandbox />
loading | Optimize loading behavior (e.g., lazy loading). | <iframe loading="lazy" />
title | Provides a title for the iframe to support accessibility. | <iframe title="Description" /> ```
<iframe src="https://example.com" />
<iframe width="500" />
<iframe height="300" />
allowFullScreen
<iframe allowFullScreen />
sandbox
<iframe sandbox />
loading
<iframe loading="lazy" />
title
<iframe title="Description" />
```For a comprehensive list of iframe attributes, refer to theMDN documentation. ### Choosing a video embedding method Choose the embedding method that aligns with your application's requirements and the user experience you aim to deliver. ### Embedding externally hosted videos 1. Create a Server Component for video embedding The first step is to create aServer Componentthat generates the appropriate iframe for embedding the video. This component will fetch the source URL for the video and render the iframe. ```
exportdefaultasyncfunctionVideoComponent() {constsrc=awaitgetVideoSrc()return<iframesrc={src}allowFullScreen/>}
```
import{ Suspense }from'react'importVideoComponentfrom'../ui/VideoComponent.jsx'exportdefaultfunctionPage() {return(<section><Suspensefallback={<p>Loading video...</p>}><VideoComponent/></Suspense>{/* Other content of the page */}</section>)}
```Good to know: When embedding videos from external platforms, consider the following best practices: • Ensure the video embeds are responsive. Use CSS to make the iframe or video player adapt to different screen sizes.
• Implementstrategies for loading videosbased on network conditions, especially for users with limited data plans. This approach results in a better user experience as it prevents the page from blocking, meaning the user can interact with the page while the video component streams in. ```
import{ Suspense }from'react'importVideoComponentfrom'../ui/VideoComponent.jsx'importVideoSkeletonfrom'../ui/VideoSkeleton.jsx'exportdefaultfunctionPage() {return(<section><Suspensefallback={<VideoSkeleton/>}><VideoComponent/></Suspense>{/* Other content of the page */}</section>)} ## Self-hosted videos Self-hosting videos may be preferable for several reasons: • Customization for specific needs: Ideal for unique requirements, like dynamic background videos, it allows for tailored customization to align with design and functional needs.
• Performance and scalability considerations: Choose storage solutions that are both high-performing and scalable, to support increasing traffic and content size effectively.
• Cost and integration: Balance the costs of storage and bandwidth with the need for easy integration into your Next.js framework and broader tech ecosystem. ### Using Vercel Blob for video hosting In your Vercel dashboard, navigate to the "Storage" tab and select yourVercel Blobstore. In the Blob table's upper-right corner, find and click the "Upload" button. Then, choose the video file you wish to upload. After the upload completes, the video file will appear in the Blob table. Alternatively, you can upload your video using a server action. For detailed instructions, refer to the Vercel documentation onserver-side uploads. Vercel also supportsclient-side uploads. This method may be preferable for certain use cases. ```
import{ Suspense }from'react'import{ list }from'@vercel/blob'exportdefaultfunctionPage() {return(<Suspensefallback={<p>Loading video...</p>}><VideoComponentfileName="my-video.mp4"/></Suspense>)}asyncfunctionVideoComponent({ fileName }) {const{blobs}=awaitlist({prefix:fileName,limit:1,})const{url}=blobs[0]return(<videocontrolspreload="none"aria-label="Video player"><sourcesrc={url}type="video/mp4"/>Your browser does not support the video tag.</video>)}
```
@vercel/blob
VideoComponent ### Adding subtitles to your video If you have subtitles for your video, you can easily add them using the<track>element inside your<video>tag. You can fetch the subtitle file fromVercel Blobin a similar way as the video file. Here's how you can update the<VideoComponent>to include subtitles. ```
<VideoComponent>
asyncfunctionVideoComponent({ fileName }) {const{blobs}=awaitlist({prefix:fileName,limit:2,})const{url}=blobs[0]const{ url:captionsUrl}=blobs[1]return(<videocontrolspreload="none"aria-label="Video player"><sourcesrc={url}type="video/mp4"/><tracksrc={captionsUrl}kind="subtitles"srcLang="en"label="English"/>Your browser does not support the video tag.</video>)} ## Resources To continue learning more about video optimization and best practices, please refer to the following resources: • Video compression: Use tools like FFmpeg to effectively compress videos, balancing quality with file size. Learn about compression techniques atFFmpeg's official website.
• Resolution and bitrate adjustment: Adjustresolution and bitratebased on the viewing platform, with lower settings for mobile devices. ### Open sourcenext-videocomponent ```
next-video

================================================================================

# Font Optimization ```
next/font
size-adjust
```This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets.No requests are sent to Google by the browser. ## Google Fonts Automatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment.No requests are sent to Google by the browser. ```
next/font/google
import{ Inter }from'next/font/google'// If loading a variable font, you don't need to specify the font weightconstinter=Inter({subsets:['latin'],display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"className={inter.className}><body>{children}</body></html>)}
```
import{ Roboto }from'next/font/google'constroboto=Roboto({weight:'400',subsets:['latin'],display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"className={roboto.className}><body>{children}</body></html>)}
```You can specify multiple weights and/or styles by using an array: ```
constroboto=Roboto({weight:['400','700'],style:['normal','italic'],subsets:['latin'],display:'swap',})
```
Roboto Mono
RobotoMono ### Specifying a subset Google Fonts are automaticallysubset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets whilepreloadistruewill result in a warning. ```
preload
true
```This can be done by adding it to the function call: ```
constinter=Inter({ subsets:['latin'] })
```
className
import{ Inter,RobotoMono }from'next/font/google'exportconstinter=Inter({subsets:['latin'],display:'swap',})exportconstrobotomono=RobotoMono({subsets:['latin'],display:'swap',})
import{ inter }from'./fonts'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<htmllang="en"className={inter.className}><body><div>{children}</div></body></html>)}
import{ robotomono }from'./fonts'exportdefaultfunctionPage() {return(<><h1className={robotomono.className}>My page</h1></>)}
```In the example above,Interwill be applied globally, andRoboto Monocan be imported and applied as needed. ```
Inter
```
import{ Inter,RobotoMono }from'next/font/google'importstylesfrom'./global.css'constinter=Inter({subsets:['latin'],variable:'--font-inter',display:'swap',})constrobotomono=RobotoMono({subsets:['latin'],variable:'--font-roboto-mono',display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"className={`${inter.variable}${robotomono.variable}`}><body><h1>My App</h1><div>{children}</div></body></html>)}
html{font-family:var(--font-inter);}h1{font-family:var(--font-roboto-mono);}
```In the example above,Interwill be applied globally, and any<h1>tags will be styled withRoboto Mono. ```
<h1>
```
next/font/local
src
importlocalFontfrom'next/font/local'// Font files can be colocated inside of `app`constmyFont=localFont({src:'./my-font.woff2',display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"className={myFont.className}><body>{children}</body></html>)}
```If you want to use multiple files for a single font family,srccan be an array: ```
constroboto=localFont({src:[{path:'./Roboto-Regular.woff2',weight:'400',style:'normal',},{path:'./Roboto-Italic.woff2',weight:'400',style:'italic',},{path:'./Roboto-Bold.woff2',weight:'700',style:'normal',},{path:'./Roboto-BoldItalic.woff2',weight:'700',style:'italic',},],}) ## With Tailwind CSS ```
variable
inter
robotomono
inter.variable
robotomono.variable
```
<html>
<body>
import{ Inter,RobotoMono }from'next/font/google'constinter=Inter({subsets:['latin'],display:'swap',variable:'--font-inter',})constrobotomono=RobotoMono({subsets:['latin'],display:'swap',variable:'--font-roboto-mono',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"className={`${inter.variable}${robotomono.variable}antialiased`}><body>{children}</body></html>)}
```Finally, add the CSS variable to yourTailwind CSS config: ### Tailwind CSS v4 As ofTailwind v4, there is zero configuration required by default. If you do need to configure Tailwind, you can follow theofficial documentationfor configuring the global CSS file. ```
@import"tailwindcss";@theme inline {--font-sans:var(--font-inter);--font-mono:var(--font-roboto-mono);} ### Tailwind CSS v3 ```
/**@type{import('tailwindcss').Config}*/module.exports={content:['./pages/**/*.{js,ts,jsx,tsx}','./components/**/*.{js,ts,jsx,tsx}','./app/**/*.{js,ts,jsx,tsx}',],theme:{extend:{fontFamily:{sans:['var(--font-inter)'],mono:['var(--font-roboto-mono)'],},},},plugins:[],}
```
font-sans
font-mono
<p class="font-sans ...">The quick brown fox ...</p>
<p class="font-mono ...">The quick brown fox ...</p> ## Preloading When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related routes based on the type of file where it is used: • If it's aunique page, it is preloaded on the unique route for that page.
• If it's alayout, it is preloaded on all the routes wrapped by the layout.
• If it's theroot layout, it is preloaded on all routes. ## Reusing fonts Every time you call thelocalFontor Google font function, that font is hosted as one instance in your application. Therefore, if you load the same font function in multiple files, multiple instances of the same font are hosted. In this situation, it is recommended to do the following: ```
localFont

================================================================================

# OpenTelemetry We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
ReadOfficial OpenTelemetry docsfor more information about OpenTelemetry and how it works. This documentation uses terms likeSpan,TraceorExporterthroughout this doc, all of which can be found inthe OpenTelemetry Observability Primer. ```
getStaticProps ## Getting Started OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package@vercel/otelthat helps you get started quickly. ```
@vercel/otel ### Using@vercel/otel To get started, install the following packages: ```
npminstall@vercel/otel@opentelemetry/sdk-logs@opentelemetry/api-logs@opentelemetry/instrumentation
instrumentation.ts
.js
src
import{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel({ serviceName:'next-app'})}
```See the@vercel/oteldocumentationfor additional configuration options. Good to know: • Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.
• If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.
• We have created a basicwith-opentelemetryexample that you can use. ```
instrumentation
app
pages
pageExtensions ### Manual OpenTelemetry configuration The@vercel/otelpackage provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually. Firstly you need to install OpenTelemetry packages: ```
npminstall@opentelemetry/sdk-node@opentelemetry/resources@opentelemetry/semantic-conventions@opentelemetry/sdk-trace-node@opentelemetry/exporter-trace-otlp-http
NodeSDK
process.env.NEXTRUNTIME === 'nodejs'
instrumentation.node.ts
exportasyncfunctionregister() {if(process.env.NEXTRUNTIME==='nodejs') {awaitimport('./instrumentation.node.ts')}}
import{ OTLPTraceExporter }from'@opentelemetry/exporter-trace-otlp-http'import{ Resource }from'@opentelemetry/resources'import{ NodeSDK }from'@opentelemetry/sdk-node'import{ SimpleSpanProcessor }from'@opentelemetry/sdk-trace-node'import{ ATTRSERVICENAME }from'@opentelemetry/semantic-conventions'constsdk=newNodeSDK({resource:newResource({[ATTRSERVICENAME]:'next-app',}),spanProcessor:newSimpleSpanProcessor(newOTLPTraceExporter()),})sdk.start()
```
We recommend using ourOpenTelemetry dev environment. If everything works well you should be able to see the root server span labeled asGET /requested/pathname.
All other spans from that particular trace will be nested under it. ```
GET /requested/pathname
NEXTOTELVERBOSE=1 ## Deployment ### Using OpenTelemetry Collector When you are deploying with OpenTelemetry Collector, you can use@vercel/otel.
It will work both on Vercel and when self-hosted. #### Deploying on Vercel We made sure that OpenTelemetry works out of the box on Vercel. FollowVercel documentationto connect your project to an observability provider. #### Self-hosting ### Custom Exporters OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with@vercel/otelormanual OpenTelemetry configuration. ## Custom Spans You can add a custom span withOpenTelemetry APIs. ```
npminstall@opentelemetry/api
```The following example demonstrates a function that fetches GitHub stars and adds a customfetchGithubStarsspan to track the fetch request's result: ```
fetchGithubStars
import{ trace }from'@opentelemetry/api'exportasyncfunctionfetchGithubStars() {returnawaittrace.getTracer('nextjs-example').startActiveSpan('fetchGithubStars',async(span)=>{try{returnawaitgetValue()}finally{span.end()}})}
```
You can start creating new spans, and they should be correctly added to the exported trace. ```
register ## Default Spans in Next.js ```
next
```• next.spanname- duplicates span name
• next.spantype- each span type has a unique identifier
• next.route- The route pattern of the request (e.g.,/[param]/user).
• next.rsc(true/false) - Whether the request is an RSC request, such as prefetch. ```
next.spanname
next.spantype
next.route
/[param]/user
next.rsc
next.page
```
• You can think about it as a route to a special file (likepage.ts,layout.ts,loading.tsand others)
• It can be used as a unique identifier only when paired withnext.routebecause/layoutcan be used to identify both/(groupA)/layout.tsand/(groupB)/layout.ts ```
page.ts
layout.ts
loading.ts
/layout
/(groupA)/layout.ts
/(groupB)/layout.ts ### [http.method] [next.route] • next.spantype:BaseServer.handleRequest ```
BaseServer.handleRequest
```Attributes: • Common HTTP attributeshttp.methodhttp.statuscode
• Server HTTP attributeshttp.routehttp.target • http.method
• http.statuscode • http.route
• http.target ### render route (app) [next.route] • next.spantype:AppRender.getBodyResult. ```
AppRender.getBodyResult
```
AppRender.fetch
```This span represents the fetch request executed in your code. • Common HTTP attributeshttp.method
• Client HTTP attributeshttp.urlnet.peer.namenet.peer.port(only if specified) • http.url
• net.peer.name
• net.peer.port(only if specified) ```
net.peer.port
NEXTOTELFETCHDISABLED=1 ### executing api route (app) [next.route] • next.spantype:AppRouteRouteHandlers.runHandler. ```
AppRouteRouteHandlers.runHandler
```
Render.getServerSideProps
```This span represents the execution ofgetServerSidePropsfor a specific route. ```
getServerSideProps ### getStaticProps [next.route] • next.spantype:Render.getStaticProps. ```
Render.getStaticProps
```
Render.renderDocument
```This span represents the process of rendering the document for a specific route. ### generateMetadata [next.page] • next.spantype:ResolveMetadata.generateMetadata. ```
ResolveMetadata.generateMetadata
```
NextNodeServer.findPageComponents
```This span represents the process of resolving page components for a specific page. ### resolve segment modules • next.spantype:NextNodeServer.getLayoutOrPageModule. ```
NextNodeServer.getLayoutOrPageModule
```
NextNodeServer.startResponse

================================================================================

# Analytics ```
useReportWebVitals ## Client Instrumentation ```
instrumentation-client.js|ts
```To use it, create aninstrumentation-client.jsorinstrumentation-client.tsfile in your application's root directory: ```
instrumentation-client.js
instrumentation-client.ts
// Initialize analytics before the app startsconsole.log('Analytics initialized')// Set up global error trackingwindow.addEventListener('error',(event)=>{// Send to your error tracking servicereportError(event.error)}) ## Build Your Own ```
'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{console.log(metric)})}
import{ WebVitals }from'./_components/web-vitals'exportdefaultfunctionLayout({ children }) {return(<html><body><WebVitals/>{children}</body></html>)}
```
"use client"
WebVitals
```View theAPI Referencefor more information. ## Web Vitals Web Vitalsare a set of useful metrics that aim to capture the user
experience of a web page. The following web vitals are all included: • Time to First Byte(TTFB)
• First Contentful Paint(FCP)
• Largest Contentful Paint(LCP)
• First Input Delay(FID)
• Cumulative Layout Shift(CLS)
• Interaction to Next Paint(INP) You can handle all the results of these metrics using thenameproperty. ```
name
'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{switch(metric.name) {case'FCP': {// handle FCP results}case'LCP': {// handle LCP results}// ...}})} ## Sending results to external systems You can send results to any endpoint to measure and track
real user performance on your site. For example: ```
useReportWebVitals((metric)=>{constbody=JSON.stringify(metric)consturl='https://example.com/analytics'// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.if(navigator.sendBeacon) {navigator.sendBeacon(url,body)}else{fetch(url,{ body,method:'POST',keepalive:true})}})
```
etc.) ```
id
useReportWebVitals((metric)=>{// Use `window.gtag` if you initialized Google Analytics as this example:// https://github.com/vercel/next.js/blob/canary/examples/with-google-analyticswindow.gtag('event',metric.name,{value:Math.round(metric.name==='CLS'?metric.value*1000:metric.value),// values must be integerseventlabel:metric.id,// id unique to current page loadnoninteraction:true,// avoids affecting bounce rate.})})

================================================================================

# ImageResponse TheImageResponseconstructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more. The following options are available forImageResponse: ```
import{ ImageResponse }from'next/og'newImageResponse(element: ReactElement,options: {width?:number=1200height?:number=630emoji?:'twemoji'|'blobmoji'|'noto'|'openmoji'='twemoji',fonts?:{name:string,data:ArrayBuffer,weight:number,style:'normal'|'italic'}[]debug?:boolean=false// Options that will be passed to the HTTP responsestatus?:number=200statusText?:stringheaders?:Record<string,string>},) ## Supported CSS Properties Please refer toSatori’s documentationfor a list of supported HTML and CSS features. ## Version History Version | Changes
v14.0.0 | ImageResponsemoved fromnext/servertonext/og
v13.3.0 | ImageResponsecan be imported fromnext/server.
v13.0.0 | ImageResponseintroduced via@vercel/ogpackage. ```
v14.0.0
next/server
next/og
v13.3.0
v13.0.0
@vercel/og
================================================================================

================================================================================

# Memory Usage As applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds. ## Reduce number of dependencies Applications with a large amount of dependencies will use more memory. TheBundle Analyzercan help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage. ## Tryexperimental.webpackMemoryOptimizations ```
experimental.webpackMemoryOptimizations
v15.0.0
experimental.webpackMemoryOptimizations: true
next.config.js
```Good to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk. ## Runnext buildwith--experimental-debug-memory-usage ```
next build
--experimental-debug-memory-usage
14.2.0
next build --experimental-debug-memory-usage
```
--heap-prof
node--heap-profnodemodules/next/dist/bin/nextbuild
```At the end of the build, a.heapprofilefile will be created by Node.js. ```
.heapprofile
```
next dev
NODEOPTIONS=--inspect
--inspect-brk
```While running in this mode, you can send aSIGUSR2signal to the process at any point, and the process will take a heap snapshot. ```
SIGUSR2
```
v14.1.0
experimental.webpackBuildWorker: true
```Good to know: This feature may not be compatible with all custom Webpack plugins. ## Disable Webpack cache TheWebpack cachesaves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can
help with performance, but it will also increase the memory usage of your application to store the cached data. You can disable this behavior by adding acustom Webpack configurationto your application: ```
/**@type{import('next').NextConfig}*/constnextConfig={webpack:(config,{ buildId,dev,isServer,defaultLoaders,nextRuntime,webpack })=>{if(config.cache&&!dev) {config.cache=Object.freeze({type:'memory',})}// Important: return the modified configreturnconfig},}exportdefaultnextConfig ## Disable static analysis Typechecking and linting may require a lot of memory, especially in large projects.
However, most projects have a dedicated CI runner that already handles these tasks.
When the build produces out-of-memory issues during the "Linting and checking validity of types" step, you can disable these task during builds: ```
/**@type{import('next').NextConfig}*/constnextConfig={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfig
```
• ESLint in Next.js config Keep in mind that this may produce faulty deploys due to type errors or linting issues.
We strongly recommend only promoting builds to production after static analysis has completed.
If you deploy to Vercel, you can check out theguide for staging deploymentsto learn how to promote builds to production after custom tasks have succeeded. ## Disable source maps Generating source maps consumes extra memory during the build process. ```
productionBrowserSourceMaps: false
experimental.serverSourceMaps: false

================================================================================

# Lazy Loading • UsingDynamic Importswithnext/dynamic
• UsingReact.lazy()withSuspense ```
next/dynamic
React.lazy() app
pages ## Examples ### Importing Client Components ```
'use client'import{ useState }from'react'importdynamicfrom'next/dynamic'// Client Components:constComponentA=dynamic(()=>import('../components/A'))constComponentB=dynamic(()=>import('../components/B'))constComponentC=dynamic(()=>import('../components/C'),{ ssr:false})exportdefaultfunctionClientComponentExample() {const[showMore,setShowMore]=useState(false)return(<div>{/* Load immediately, but in a separate client bundle */}<ComponentA/>{/* Load on demand, only when/if the condition is met */}{showMore&&<ComponentB/>}<buttononClick={()=>setShowMore(!showMore)}>Toggle</button>{/* Load only on the client side */}<ComponentC/></div>)}
```Note:When a Server Component dynamically imports a Client Component, automaticcode splittingis currentlynotsupported. ### Skipping SSR When usingReact.lazy()and Suspense, Client Components will beprerendered(SSR) by default. Note:ssr: falseoption will only work for Client Components, move it into Client Components ensure the client code-splitting working properly. ```
ssr: false
```
ssr
false
constComponentC=dynamic(()=>import('../components/C'),{ ssr:false}) ### Importing Server Components If you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself.
It will also help preload the static assets such as CSS when you're using it in Server Components. ```
importdynamicfrom'next/dynamic'// Server Component:constServerComponent=dynamic(()=>import('../components/ServerComponent'))exportdefaultfunctionServerComponentExample() {return(<div><ServerComponent/></div>)} ### Loading External Libraries ```
import()
fuse.js
'use client'import{ useState }from'react'constnames=['Tim','Joe','Bel','Lee']exportdefaultfunctionPage() {const[results,setResults]=useState()return(<div><inputtype="text"placeholder="Search"onChange={async(e)=>{const{value}=e.currentTarget// Dynamically load fuse.jsconstFuse=(awaitimport('fuse.js')).defaultconstfuse=newFuse(names)setResults(fuse.search(value))}}/><pre>Results: {JSON.stringify(results,null,2)}</pre></div>)} ### Adding a custom loading component ```
'use client'importdynamicfrom'next/dynamic'constWithCustomLoading=dynamic(()=>import('../components/WithCustomLoading'),{loading:()=><p>Loading...</p>,})exportdefaultfunctionPage() {return(<div>{/* The loading component will be rendered while <WithCustomLoading/> is loading */}<WithCustomLoading/></div>)} ### Importing Named Exports To dynamically import a named export, you can return it from the Promise returned byimport()function: ```
'use client'exportfunctionHello() {return<p>Hello!</p>}
importdynamicfrom'next/dynamic'constClientComponent=dynamic(()=>import('../components/hello').then((mod)=>mod.Hello))
================================================================================

================================================================================

# Metadata ```
meta
link
head
```There are two ways you can add metadata to your application: • Config-based Metadata: Export astaticmetadataobjector a dynamicgenerateMetadatafunctionin alayout.jsorpage.jsfile.
• File-based Metadata: Add static or dynamically generated special files to route segments. ```
metadata
generateMetadata
layout.js
page.js
<head>
ImageResponse ## Static Metadata To define static metadata, export aMetadataobjectfrom alayout.jsor staticpage.jsfile. ```
importtype{ Metadata }from'next'exportconstmetadata:Metadata={title:'...',description:'...',}exportdefaultfunctionPage() {}
```
fetch
importtype{ Metadata,ResolvingMetadata }from'next'typeProps={params:Promise<{ id:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}exportasyncfunctiongenerateMetadata({ params,searchParams }:Props,parent:ResolvingMetadata):Promise<Metadata> {// read route paramsconst{id}=awaitparams// fetch dataconstproduct=awaitfetch(`https://.../${id}`).then((res)=>res.json())// optionally access and extend (rather than replace) parent metadataconstpreviousImages=(awaitparent).openGraph?.images||[]return{title:product.title,openGraph:{images:['/some-specific-page-image.jpg',...previousImages],},}}exportdefaultfunctionPage({ params,searchParams }:Props) {}
```For all the available params, see theAPI Reference. Good to know: • Both static and dynamic metadata throughgenerateMetadataareonly supported in Server Components.
• fetchrequests are automaticallymemoizedfor the same data acrossgenerateMetadata,generateStaticParams, Layouts, Pages, and Server Components. Reactcachecan be usediffetchis unavailable.
• Next.js will wait for data fetching insidegenerateMetadatato complete before streaming UI to the client. This guarantees the first part of astreamed responseincludes<head>tags. ```
generateStaticParams
cache ## File-based metadata These special files are available for metadata: • favicon.ico, apple-icon.jpg, and icon.jpg
• opengraph-image.jpg and twitter-image.jpg
• robots.txt
• sitemap.xml You can use these for static metadata, or you can programmatically generate these files with code. For implementation and examples, see theMetadata FilesAPI Reference andDynamic Image Generation. ## Behavior File-based metadata has the higher priority and will override any config-based metadata. ### Default Fields There are two defaultmetatags that are always added even if a route doesn't define metadata: • Themeta charset tagsets the character encoding for the website.
• Themeta viewport tagsets the viewport width and scale for the website to adjust for different devices. ```
<metacharset="utf-8"/><metaname="viewport"content="width=device-width, initial-scale=1"/>
```
viewport ### Ordering Metadata is evaluated in order, starting from the root segment down to the segment closest to the finalpage.jssegment. For example: • app/layout.tsx(Root Layout)
• app/blog/layout.tsx(Nested Blog Layout)
• app/blog/[slug]/page.tsx(Blog Page) ```
app/layout.tsx
app/blog/layout.tsx
app/blog/[slug]/page.tsx ### Merging Following theevaluation order, Metadata objects exported from multiple segments in the same route areshallowlymerged together to form the final metadata output of a route. Duplicate keys arereplacedbased on their ordering. This means metadata with nested fields such asopenGraphandrobotsthat are defined in an earlier segment areoverwrittenby the last segment to define them. ```
openGraph
robots #### Overwriting fields ```
exportconstmetadata={title:'Acme',openGraph:{title:'Acme',description:'Acme is a...',},}
exportconstmetadata={title:'Blog',openGraph:{title:'Blog',},}// Output:// <title>Blog</title>// <meta property="og:title" content="Blog" />
```In the example above: • titlefromapp/layout.jsisreplacedbytitleinapp/blog/page.js.
• AllopenGraphfields fromapp/layout.jsarereplacedinapp/blog/page.jsbecauseapp/blog/page.jssetsopenGraphmetadata. Note the absence ofopenGraph.description. ```
title
app/layout.js
app/blog/page.js
openGraph.description
```
exportconstopenGraphImage={ images:['http://...'] }
import{ openGraphImage }from'./shared-metadata'exportconstmetadata={openGraph:{...openGraphImage,title:'Home',},}
import{ openGraphImage }from'../shared-metadata'exportconstmetadata={openGraph:{...openGraphImage,title:'About',},}
```In the example above, the OG image is shared betweenapp/layout.jsandapp/about/page.jswhile the titles are different. ```
app/about/page.js #### Inheriting fields ```
exportconstmetadata={title:'About',}// Output:// <title>About</title>// <meta property="og:title" content="Acme" />// <meta property="og:description" content="Acme is a..." />
```
• AllopenGraphfields fromapp/layout.jsareinheritedinapp/about/page.jsbecauseapp/about/page.jsdoesn't setopenGraphmetadata. ## Dynamic Image Generation TheImageResponseconstructor allows you to generate dynamic images using JSX and CSS. This is useful for creating social media images such as Open Graph images, Twitter cards, and more. ```
next/og
import{ ImageResponse }from'next/og'exportdefaultfunctionOG() {returnnewImageResponse((<divstyle={{fontSize:128,background:'white',width:'100%',height:'100%',display:'flex',textAlign:'center',alignItems:'center',justifyContent:'center',}}>Hello world!</div>),{width:1200,height:600,})}
opengraph-image.tsx
```ImageResponsesupports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images.See the full list of supported CSS properties. • Examples are available in theVercel OG Playground.
• ImageResponseuses@vercel/og,Satori, and Resvg to convert HTML and CSS into PNG.
• Only flexbox and a subset of CSS properties are supported. Advanced layouts (e.g.display: grid) will not work.
• Maximum bundle size of500KB. The bundle size includes your JSX, CSS, fonts, images, and any other assets. If you exceed the limit, consider reducing the size of any assets or fetching at runtime.
• Onlyttf,otf, andwofffont formats are supported. To maximize the font parsing speed,ttforotfare preferred overwoff. ```
display: grid
500KB
ttf
otf
woff ## JSON-LD Our current recommendation for JSON-LD is to render structured data as a<script>tag in yourlayout.jsorpage.jscomponents. For example: ```
<script>
exportdefaultasyncfunctionPage({ params }) {const{id}=awaitparamsconstproduct=awaitgetProduct(id)constjsonLd={'@context':'https://schema.org','@type':'Product',name:product.name,image:product.image,description:product.description,}return(<section>{/* Add JSON-LD to your page */}<scripttype="application/ld+json"dangerouslySetInnerHTML={{ __html:JSON.stringify(jsonLd) }}/>{/* ... */}</section>)}
```
schema-dts
import{ Product,WithContext }from'schema-dts'constjsonLd:WithContext<Product>={'@context':'https://schema.org','@type':'Product',name:'Next.js Sticker',image:'https://nextjs.org/imgs/sticker.png',description:'Dynamic at the speed of static.',} ## Next Steps ### Metadata Files ### generateViewport
================================================================================

================================================================================

# Static Assets in `public` ```
public
```For example, the filepublic/avatars/me.pngcan be viewed by visiting the/avatars/me.pngpath. The code to display that image might look like: ```
public/avatars/me.png
/avatars/me.png
importImagefrom'next/image'exportfunctionAvatar({ id,alt }) {return<Imagesrc={`/avatars/${id}.png`}alt={alt}width="64"height="64"/>}exportfunctionAvatarOfMe() {return<Avatarid="me"alt="A portrait of me"/>} ## Caching ```
Cache-Control:public,max-age=0 ## Robots, Favicons, and others For static metadata files, such asrobots.txt,favicon.ico, etc, you should usespecial metadata filesinside theappfolder. ```
robots.txt
favicon.ico
app
```
================================================================================

================================================================================

# React Foundations: About React and Next.js | Next.js
URL: https://nextjs.org/learn/react-foundations/what-is-react-and-nextjs
Section: 2/2
Description: Understand the differences between React and Next.js, and how you can use them together to build modern web applications.
Category: React Foundations
Document Structure:
- Deploy
- ShowcaseDocsBlogTemplatesEnterprise
Content:
1 Chapter1 # About React and Next.js ### Building blocks of a web application There are a few things you need to consider when building modern applications. Such as: • User Interface- how users will consume and interact with your application.
• Routing- how users navigate between different parts of your application.
• Data Fetching- where your data lives and how to get it.
• Rendering- when and where you render static or dynamic content.
• Integrations- what third-party services you use (for CMS, auth, payments, etc.) and how you connect to them.
• Infrastructure- where you deploy, store, and run your application code (serverless, CDN, edge, etc.).
• Performance- how to optimize your application for end-users.
• Scalability- how your application adapts as your team, data, and traffic grow.
• Developer Experience- your team's experience building and maintaining your application. For each part of your application, you will need to decide whether you will build a solution yourself or use other tools, such as packages, libraries, and frameworks. ### What is React? Reactis a JavaScriptlibraryfor buildinginteractive user interfaces. By user interfaces (UI), we mean the elements that users see and interact with on-screen. By library, we mean React provides helpful functions (APIs) to build UI, but leaves it up to the developer where to use those functions in their application. It also means, however, that building a complete React application from the ground up requires some effort. Developers need to spend time configuring tools and reinventing solutions for common application requirements. ## What is Next.js? ## You've Completed Chapter1 2: Rendering User Interfaces (UI) Learn the fundamentals of how user interfaces (UI) are rendered in the browser.
================================================================================

================================================================================

# Optimizing Package Bundling ## Analyzing JavaScript bundles ```
@next/bundle-analyzer ### Installation Install the plugin by running the following command: ```
npmi@next/bundle-analyzer# oryarnadd@next/bundle-analyzer# orpnpmadd@next/bundle-analyzer
next.config.js
/**@type{import('next').NextConfig}*/constnextConfig={}constwithBundleAnalyzer=require('@next/bundle-analyzer')({enabled:process.env.ANALYZE==='true',})module.exports=withBundleAnalyzer(nextConfig) ### Generating a report Run the following command to analyze your bundles: ```
ANALYZE=truenpmrunbuild# orANALYZE=trueyarnbuild# orANALYZE=truepnpmbuild

================================================================================

# React Foundations: From React to Next.js | Next.js
URL: https://nextjs.org/learn/react-foundations/from-react-to-nextjs
Section: 2/2
Description: How to continue learning React, and get ready to learn Next.js.
Category: React Foundations
Document Structure:
- Deploy
- ShowcaseDocsBlogTemplatesEnterprise
Content:
8 Chapter8 # From React to Next.js So far, we explored how you can get started with React. This is what the final code looked like. If you're starting from here, paste this code into anindex.htmlfile in your code editor. ```
index.html
<html><body><divid="app"></div><scriptsrc="https://unpkg.com/react@18/umd/react.development.js"></script><scriptsrc="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script><scriptsrc="https://unpkg.com/@babel/standalone/babel.min.js"></script><scripttype="text/jsx">const app = document.getElementById("app")function Header({ title }) {return <h1>{title?title:"Default title"}</h1>}function HomePage() {const names=["Ada Lovelace","Grace Hopper","Margaret Hamilton"]const [likes,setLikes]=React.useState(0)functionhandleClick() {setLikes(likes+1)}return(<div><Headertitle="Develop. Preview. Ship."/><ul>{names.map((name)=>(<likey={name}>{name}</li>))}</ul><buttononClick={handleClick}>Like ({likes})</button></div>)}const root = ReactDOM.createRoot(app);root.render(<HomePage/>);</script></body></html>

================================================================================

# Instrumentation Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production. ## Convention To set up instrumentation, createinstrumentation.ts|jsfile in theroot directoryof your project (or inside thesrcfolder if using one). ```
instrumentation.ts|js
src
register
import{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel('next-app')}
```Good to know: • Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.
• If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match. ```
instrumentation
app
pages
pageExtensions ## Examples ### Importing files with side effects Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared. We recommend importing files using JavaScriptimportsyntax within yourregisterfunction. The following example demonstrates a basic usage ofimportin aregisterfunction: ```
import
exportasyncfunctionregister() {awaitimport('package-with-side-effect')}
```
NEXTRUNTIME
exportasyncfunctionregister() {if(process.env.NEXTRUNTIME==='nodejs') {awaitimport('./instrumentation-node')}if(process.env.NEXT_RUNTIME==='edge') {awaitimport('./instrumentation-edge')}}
================================================================================

================================================================================

# Route Groups In theappdirectory, nested folders are normally mapped to URL paths. However, you can mark a folder as aRoute Groupto prevent the folder from being included in the route's URL path. ```
app
```This allows you to organize your route segments and project files into logical groups without affecting the URL path structure. Route groups are useful for: • Organizing routes into groups e.g. by site section, intent, or team.
• Enabling nested layouts in the same route segment level:Creating multiple nested layouts in the same segment, including multiple root layoutsOpting specific segments into a layout
• Opting for loading skeletons on a specific route • Creating multiple nested layouts in the same segment, including multiple root layouts
• Opting specific segments into a layout ## Convention A route group can be created by wrapping a folder's name in parenthesis:(folderName) ```
(folderName)
```
• If you use multiple root layouts without a top-levellayout.jsfile, your homepage.jsfile should be defined in one of the route groups, For example:app/(marketing)/page.js. ```
(marketing)/about/page.js
(shop)/about/page.js
/about
layout.js
page.js
app/(marketing)/page.js
/cart
app/(shop)/layout.js
/blog
app/(marketing)/layout.js
================================================================================

================================================================================

# Parallel Routes Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites. For example, considering a dashboard, you can use parallel routes to simultaneously render theteamandanalyticspages: ```
team
analytics ## Slots Parallel routes are created using namedslots. Slots are defined with the@folderconvention. For example, the following file structure defines two slots:@analyticsand@team: ```
@folder
@analytics
@team
```Slots are passed as props to the shared parent layout. For the example above, the component inapp/layout.jsnow accepts the@analyticsand@teamslots props, and can render them in parallel alongside thechildrenprop: ```
app/layout.js
children
exportdefaultfunctionLayout({children,team,analytics,}:{children:React.ReactNodeanalytics:React.ReactNodeteam:React.ReactNode}) {return(<>{children}{team}{analytics}</>)}
```
/@analytics/views
/views
```Good to know: • Thechildrenprop is an implicit slot that does not need to be mapped to a folder. This meansapp/page.jsis equivalent toapp/@children/page.js. ```
app/page.js
app/@children/page.js ## Active state and navigation ```
default.js
404
```
/settings
```When navigating to/settings, the@teamslot will render the/settingspage while maintaining the currently active page for the@analyticsslot. ### useSelectedLayoutSegment(s) BothuseSelectedLayoutSegmentanduseSelectedLayoutSegmentsaccept aparallelRoutesKeyparameter, which allows you to read the active route segment within a slot. ```
useSelectedLayoutSegment
useSelectedLayoutSegments
parallelRoutesKey
'use client'import{ useSelectedLayoutSegment }from'next/navigation'exportdefaultfunctionLayout({ auth }:{ auth:React.ReactNode}) {constloginSegment=useSelectedLayoutSegment('auth')// ...}
```
app/@auth/login
/login
loginSegment
"login" ## Examples ### Conditional Routes You can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the/adminor/userroles: ```
/admin
/user
import{ checkUserRole }from'@/lib/auth'exportdefaultfunctionLayout({user,admin,}:{user:React.ReactNodeadmin:React.ReactNode}) {constrole=checkUserRole()returnrole==='admin'?admin:user} ### Tab Groups You can add alayoutinside a slot to allow users to navigate the slot independently. This is useful for creating tabs. ```
layout
```For example, the@analyticsslot has two subpages:/page-viewsand/visitors. ```
/page-views
/visitors
```
importLinkfrom'next/link'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Linkhref="/page-views">Page Views</Link><Linkhref="/visitors">Visitors</Link></nav><div>{children}</div></>)} ### Modals Parallel Routes can be used together withIntercepting Routesto create modals that support deep linking. This allows you to solve common challenges when building modals, such as: • Making the modal contentshareable through a URL.
• Preserving contextwhen the page is refreshed, instead of closing the modal.
• Closing the modal on backwards navigationrather than going to the previous route.
• Reopening the modal on forwards navigation. Consider the following UI pattern, where a user can open a login modal from a layout using client-side navigation, or access a separate/loginpage: To implement this pattern, start by creating a/loginroute that renders yourmainlogin page. ```
import{ Login }from'@/app/ui/login'exportdefaultfunctionPage() {return<Login/>}
```Then, inside the@authslot, adddefault.jsfile that returnsnull. This ensures that the modal is not rendered when it's not active. ```
@auth
null
exportdefaultfunctionDefault() {returnnull}
```
/(.)login
<Modal>
/(.)login/page.tsx
import{ Modal }from'@/app/ui/modal'import{ Login }from'@/app/ui/login'exportdefaultfunctionPage() {return(<Modal><Login/></Modal>)}
```• The convention used to intercept the route, e.g.(.), depends on your file-system structure. SeeIntercepting Routes convention. ```
<Login> #### Opening the modal To open the modal, pass the@authslot as a prop to the parent layout and render it alongside thechildrenprop. ```
importLinkfrom'next/link'exportdefaultfunctionLayout({auth,children,}:{auth:React.ReactNodechildren:React.ReactNode}) {return(<><nav><Linkhref="/login">Open modal</Link></nav><div>{auth}</div><div>{children}</div></>)}
```
<Link> #### Closing the modal You can close the modal by callingrouter.back()or by using theLinkcomponent. ```
router.back()
Link
'use client'import{ useRouter }from'next/navigation'exportfunctionModal({ children }:{ children:React.ReactNode}) {constrouter=useRouter()return(<><buttononClick={()=>{router.back()}}>Close modal</button><div>{children}</div></>)}
```When using theLinkcomponent to navigate away from a page that shouldn't render the@authslot anymore, we need to make sure the parallel route matches to a component that returnsnull. For example, when navigating back to the root page, we create a@auth/page.tsxcomponent: ```
@auth/page.tsx
importLinkfrom'next/link'exportfunctionModal({ children }:{ children:React.ReactNode}) {return(<><Linkhref="/">Close modal</Link><div>{children}</div></>)}
exportdefaultfunctionPage() {returnnull}
```
/foo
/foo/bar
exportdefaultfunctionCatchAll() {returnnull}

================================================================================

# How to create layouts and pages ## Creating a page Apageis UI that is rendered on a specific route. To create a page, add apagefileinside theappdirectory and default export a React component. For example, to create an index page (/): ```
page
app
exportdefaultfunctionPage() {return<h1>Hello Next.js!</h1>} ## Creating a layout A layout is UI that issharedbetween multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender. You can define a layout by default exporting a React component from alayoutfile. The component should accept achildrenprop which can be a page or anotherlayout. ```
layout
children
```For example, to create a layout that accepts your index page as child, add alayoutfile inside theappdirectory: ```
exportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{/* Layout UI */}{/* Place children where you want to render a page or nested layout */}<main>{children}</main></body></html>)}
```
html
body ## Creating a nested route A nested route is a route composed of multiple URL segments. For example, the/blog/[slug]route is composed of three segments: ```
/blog/[slug]
```• /(Root Segment)
• blog(Segment)
• slug ```
blog
[slug]
```
• Files(likepageandlayout) are used to create UI that is shown for a segment. To create nested routes, you can nest folders inside each other. For example, to add a route for/blog, create a folder calledblogin theappdirectory. Then, to make/blogpublicly accessible, add apage.tsxfile: ```
/blog
page.tsx
// Dummy importsimport{ getPosts }from'@/lib/posts'import{ Post }from'@/ui/post'exportdefaultasyncfunctionPage() {constposts=awaitgetPosts()return(<ul>{posts.map((post)=>(<Postkey={post.id}post={post} />))}</ul>)}
```You can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new[slug]folder insideblogand add apagefile: ```
functiongenerateStaticParams() {}exportdefaultfunctionPage() {return<h1>Hello, Blog Post Page!</h1>}
```
exportdefaultfunctionBlogLayout({children,}:{children:React.ReactNode}) {return<section>{children}</section>}

================================================================================

# Internationalization ## Terminology • en-US: English as spoken in the United States
• nl-NL: Dutch as spoken in the Netherlands
• nl: Dutch, no specific region ```
en-US
nl-NL
nl ## Routing Overview It’s recommended to use the user’s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incomingAccept-Languageheader to your application. ```
Accept-Language
```For example, using the following libraries, you can look at an incomingRequestto determine which locale to select, based on theHeaders, locales you plan to support, and the default locale. ```
Request
Headers
import{ match }from'@formatjs/intl-localematcher'importNegotiatorfrom'negotiator'letheaders={'accept-language':'en-US,en;q=0.5'}letlanguages=newNegotiator({ headers }).languages()letlocales=['en-US','nl-NL','nl']letdefaultLocale='en-US'match(languages,locales,defaultLocale)// -> 'en-US'
```
/fr/products
my-site.fr/products
import{ NextResponse }from"next/server";letlocales=['en-US','nl-NL','nl']// Get the preferred locale, similar to the above or using a libraryfunctiongetLocale(request) {...}exportfunctionmiddleware(request) {// Check if there is any supported locale in the pathnameconst{pathname}=request.nextUrlconstpathnameHasLocale=locales.some((locale)=>pathname.startsWith(`/${locale}/`)||pathname===`/${locale}`)if(pathnameHasLocale)return// Redirect if there is no localeconstlocale=getLocale(request)request.nextUrl.pathname=`/${locale}${pathname}`// e.g. incoming request is /products// The new URL is now /en-US/productsreturnNextResponse.redirect(request.nextUrl)}exportconstconfig={matcher:[// Skip all internal paths (next)'/((?!next).*)',// Optional: only run on root (/) URL// '/'],}
app/
app/[lang]
lang
// You now have access to the current locale// e.g. /en-US/products -> `lang` is "en-US"exportdefaultasyncfunctionPage({params,}:{params:Promise<{ lang:string}>}) {const{lang}=awaitparamsreturn...}
```The root layout can also be nested in the new folder (e.g.app/[lang]/layout.js). ```
app/[lang]/layout.js ## Localization Let’s assume we want to support both English and Dutch content inside our application. We might maintain two different “dictionaries”, which are objects that give us a mapping from some key to a localized string. For example: ```
{"products":{"cart":"Add to Cart"}}
{"products":{"cart":"Toevoegen aan Winkelwagen"}}
```
getDictionary
import'server-only'constdictionaries={en:()=>import('./dictionaries/en.json').then((module)=>module.default),nl:()=>import('./dictionaries/nl.json').then((module)=>module.default),}exportconstgetDictionary=async(locale:'en'|'nl')=>dictionaries[locale]()
```Given the currently selected language, we can fetch the dictionary inside of a layout or page. ```
import{ getDictionary }from'./dictionaries'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ lang:'en'|'nl'}>}) {const{lang}=awaitparamsconstdict=awaitgetDictionary(lang)// enreturn<button>{dict.products.cart}</button>// Add to Cart}
```
generateStaticParams
exportasyncfunctiongenerateStaticParams() {return[{ lang:'en-US'},{ lang:'de'}]}exportdefaultasyncfunctionRootLayout({children,params,}:Readonly<{children:React.ReactNodeparams:Promise<{ lang:'en-US'|'de'}>}>) {return(<htmllang={(awaitparams).lang}><body>{children}</body></html>)} ## Resources • Minimal i18n routing and translations
• next-intl
• next-international
• next-i18n-router
• paraglide-next
• lingui
================================================================================

================================================================================

# Linking and Navigating • Using the<Link>Component
• Using theuseRouterhook(Client Components)
• Using theredirectfunction(Server Components)
• Using the nativeHistory API ```
<Link>
useRouter
redirect
```This page will go through how to use each of these options, and dive deeper into how navigation works. ## <Link>Component ```
<a>
next/link
href
importLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref="/dashboard">Dashboard</Link>}
```
useRouter()
```TheuseRouterhook allows you to programmatically change routes fromClient Components. ```
'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype="button"onClick={()=>router.push('/dashboard')}>Dashboard</button>)}
```
import{ redirect }from'next/navigation'asyncfunctionfetchTeam(id:string) {constres=awaitfetch('https://...')if(!res.ok)returnundefinedreturnres.json()}exportdefaultasyncfunctionProfile({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsif(!id) {redirect('/login')}constteam=awaitfetchTeam(id)if(!team) {redirect('/join')}// ...}
```Good to know: • redirectinternally throws an error so it should be called outside oftry/catchblocks.
• redirectcan be called in Client Components during the rendering process but not in event handlers. You can use theuseRouterhookinstead.
• redirectalso accepts absolute URLs and can be used to redirect to external links.
• If you'd like to redirect before the render process, usenext.config.jsorMiddleware. ```
try/catch
next.config.js
```
window.history.pushState
window.history.replaceState
pushState
replaceState
usePathname
useSearchParams ## How Routing and Navigation Works ### 1. Code Splitting Code splitting allows you to split your application code into smaller bundles to be downloaded and executed by the browser. This reduces the amount of data transferred and execution time for each request, leading to improved performance. Server Componentsallow your application code to be automatically code-split by route segments. This means only the code needed for the current route is loaded on navigation. ### 2. Prefetching Prefetching is a way to preload a route in the background before the user visits it. • <Link>component: Routes are automatically prefetched as they become visible in the user's viewport. Prefetching happens when the page first loads or when it comes into view through scrolling.
• router.prefetch(): TheuseRouterhook can be used to prefetch routes programmatically. ```
router.prefetch()
prefetch
null
loading.js
30s
false
true
```See the<Link>API referencefor more information. • Prefetching is not enabled in development, only in production. ### 3. Caching This means on navigation, the cache is reused as much as possible, instead of making a new request to the server - improving performance by reducing the number of requests and data transferred. Learn more about how theRouter Cacheworks and how to configure it. ### 4. Partial Rendering Partial rendering means only the route segments that change on navigation re-render on the client, and any shared segments are preserved. For example, when navigating between two sibling routes,/dashboard/settingsand/dashboard/analytics, thesettingspage will be unmounted, theanalyticspage will be mounted with fresh state, and the shareddashboardlayout will be preserved. This behavior is also present between two routes on the same dynamic segment e.g. with/blog/[slug]/pageand navigating from/blog/firstto/blog/second. ```
/dashboard/settings
/dashboard/analytics
settings
analytics
dashboard
/blog/[slug]/page
/blog/first
/blog/second
```
pages/
app/
experimental.clientRouterFilterAllowedRate
experimental.clientRouterFilter ## Next Steps ### Caching ### TypeScript
================================================================================

================================================================================

# Intercepting Routes Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context. ```
/photo/123
/feed
```However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur. ## Convention Intercepting routes can be defined with the(..)convention, which is similar to relative path convention../but for segments.  You can use: • (.)to match segments on thesame level
• (..)to match segmentsone level above
• (..)(..)to match segmentstwo levels above
• (...)to match segments from therootappdirectory ```
app
```
photo
feed
(..)photo
```Note that the(..)convention is based onroute segments, not the file-system. ## Examples ### Modals Intercepting Routes can be used together withParallel Routesto create modals. This allows you to solve common challenges when building modals, such as: • Making the modal contentshareable through a URL.
• Preserving contextwhen the page is refreshed, instead of closing the modal.
• Closing the modal on backwards navigationrather than going to the previous route.
• Reopening the modal on forwards navigation. Consider the following UI pattern, where a user can open a photo modal from a gallery using client-side navigation, or navigate to the photo page directly from a shareable URL: In the above example, the path to thephotosegment can use the(..)matcher since@modalis a slot andnota segment. This means that thephotoroute is only one segment level higher, despite being two file-system levels higher. ```
@modal
```
/login ## Next Steps ### Parallel Routes
================================================================================

================================================================================

# Dynamic Routes When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time orprerenderedat build time. ## Convention A Dynamic Segment can be created by wrapping a folder's name in square brackets:[folderName]. For example,[id]or[slug]. ```
[folderName]
[id]
[slug]
```Dynamic Segments are passed as theparamsprop tolayout,page,route, andgenerateMetadatafunctions. ```
params
layout
page
route
generateMetadata ## Example For example, a blog could include the following routeapp/blog/[slug]/page.jswhere[slug]is the Dynamic Segment for blog posts. ```
app/blog/[slug]/page.js
exportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {const{slug}=awaitparamsreturn<div>My Post: {slug}</div>}
```
app/blog/[slug]/page.js | /blog/a | { slug: 'a' }
app/blog/[slug]/page.js | /blog/b | { slug: 'b' }
app/blog/[slug]/page.js | /blog/c | { slug: 'c' } ```
/blog/a
{ slug: 'a' }
/blog/b
{ slug: 'b' }
/blog/c
{ slug: 'c' }
```See thegenerateStaticParams()page to learn how to generate the params for the segment. ## Good to know • Dynamic Segments are equivalent toDynamic Routesin thepagesdirectory. • In version 14 and earlier,paramswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. ```
pages ## Generating Static Params ThegenerateStaticParamsfunction can be used in combination withdynamic route segmentstostatically generateroutes at build time instead of on-demand at request time. ```
generateStaticParams
exportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())returnposts.map((post)=>({slug:post.slug,}))}
```
fetch
```Use themigration guideif you are migrating from thepagesdirectory. SeegenerateStaticParamsserver function documentationfor more information and advanced use cases. ## Catch-all Segments Dynamic Segments can be extended tocatch-allsubsequent segments by adding an ellipsis inside the brackets[...folderName]. ```
[...folderName]
```
app/shop/[...slug]/page.js
/shop/clothes
/shop/clothes/tops
/shop/clothes/tops/t-shirts
```Route | Example URL | params
app/shop/[...slug]/page.js | /shop/a | { slug: ['a'] }
app/shop/[...slug]/page.js | /shop/a/b | { slug: ['a', 'b'] }
app/shop/[...slug]/page.js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } ```
/shop/a
{ slug: ['a'] }
/shop/a/b
{ slug: ['a', 'b'] }
/shop/a/b/c
{ slug: ['a', 'b', 'c'] } ## Optional Catch-all Segments Catch-all Segments can be madeoptionalby including the parameter in double square brackets:[[...folderName]]. ```
[[...folderName]]
```
app/shop/[[...slug]]/page.js
/shop
```The difference betweencatch-allandoptional catch-allsegments is that with optional, the route without the parameter is also matched (/shopin the example above). Route | Example URL | params
app/shop/[[...slug]]/page.js | /shop | { slug: undefined }
app/shop/[[...slug]]/page.js | /shop/a | { slug: ['a'] }
app/shop/[[...slug]]/page.js | /shop/a/b | { slug: ['a', 'b'] }
app/shop/[[...slug]]/page.js | /shop/a/b/c | { slug: ['a', 'b', 'c'] } ```
{ slug: undefined } ## TypeScript When using TypeScript, you can add types forparamsdepending on your configured route segment. ```
exportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {return<h1>My Page</h1>}
```
app/blog/[slug]/page.js | { slug: string }
app/shop/[...slug]/page.js | { slug: string[] }
app/shop/[[...slug]]/page.js | { slug?: string[] }
app/[categoryId]/[itemId]/page.js | { categoryId: string, itemId: string } ```
{ slug: string }
{ slug: string[] }
{ slug?: string[] }
app/[categoryId]/[itemId]/page.js
{ categoryId: string, itemId: string }

================================================================================

# Loading UI and Streaming ```
loading.js ## Instant Loading States ```
exportdefaultfunctionLoading() {// You can add any UI inside Loading, including a Skeleton.return<LoadingSkeleton/>}
layout.js
page.js
<Suspense>
```Good to know: • Navigation is immediate, even withserver-centric routing.
• Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route.
• Shared layouts remain interactive while new route segments load. ## Streaming with Suspense ### What is Streaming? With SSR, there's a series of steps that need to be completed before a user can see and interact with a page: • First, all data for a given page is fetched on the server.
• The server then renders the HTML for the page.
• The HTML, CSS, and JavaScript for the page are sent to the client.
• A non-interactive user interface is shown using the generated HTML, and CSS.
• Finally, Reacthydratesthe user interface to make it interactive. These steps are sequential and blocking, meaning the server can only render the HTML for a page once all the data has been fetched. And, on the client, React can only hydrate the UI once the code for all components in the page has been downloaded. However, it can still be slow as all data fetching on server needs to be completed before the page can be shown to the user. Streamingallows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client. This enables parts of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered. Streaming works well with React's component model because each component can be considered a chunk. Components that have higher priority (e.g. product information) or that don't rely on data can be sent first (e.g. layout), and React can start hydration earlier. Components that have lower priority (e.g. reviews, related products) can be sent in the same server request after their data has been fetched. Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can reduce theTime To First Byte (TTFB)andFirst Contentful Paint (FCP). It also helps improveTime to Interactive (TTI), especially on slower devices. ### Example <Suspense>works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes. ```
import{ Suspense }from'react'import{ PostFeed,Weather }from'./Components'exportdefaultfunctionPosts() {return(<section><Suspensefallback={<p>Loading feed...</p>}><PostFeed/></Suspense><Suspensefallback={<p>Loading weather...</p>}><Weather/></Suspense></section>)}
```
• Selective Hydration- React prioritizes what components to make interactive first based on user interaction. For more Suspense examples and use cases, please see theReact Documentation. ### SEO • Next.js will wait for data fetching insidegenerateMetadatato complete before streaming UI to the client. This guarantees the first part of a streamed response includes<head>tags. ```
generateMetadata
<head> ### Status Codes When streaming, a200status code will be returned to signal that the request was successful. ```
200

================================================================================

# Error Handling Errors can be divided into two categories:expected errorsanduncaught exceptions: • Model expected errors as return values: Avoid usingtry/catchfor expected errors in Server Actions. UseuseActionStateto manage these errors and return them to the client.
• Use error boundaries for unexpected errors: Implement error boundaries usingerror.tsxandglobal-error.tsxfiles to handle unexpected errors and provide a fallback UI. ```
try
catch
useActionState
error.tsx
global-error.tsx ## Handling Expected Errors Expected errors are those that can occur during the normal operation of the application, such as those fromserver-side form validationor failed requests. These errors should be handled explicitly and returned to the client. ### Handling Expected Errors from Server Actions Use theuseActionStatehook to manage the state of Server Actions, including handling errors. This approach avoidstry/catchblocks for expected errors, which should be modeled as return values rather than thrown exceptions. ```
'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreateUser(prevState:any,formData:FormData) {constres=awaitfetch('https://...')constjson=awaitres.json()if(!res.ok) {return{ message:'Please enter a valid email'}}redirect('/dashboard')}
```Then, you can pass your action to theuseActionStatehook and use the returnedstateto display an error message. ```
state
'use client'import{ useActionState }from'react'import{ createUser }from'@/app/actions'constinitialState={message:'',}exportfunctionSignup() {const[state,formAction,pending]=useActionState(createUser,initialState)return(<formaction={formAction}><labelhtmlFor="email">Email</label><inputtype="text"id="email"name="email"required/>{/* ... */}<paria-live="polite">{state?.message}</p><buttondisabled={pending}>Sign up</button></form>)}
```
redirect
exportdefaultasyncfunctionPage() {constres=awaitfetch(`https://...`)constdata=awaitres.json()if(!res.ok) {return'There was an error.'}return'...'} ## Uncaught Exceptions Uncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries. • Common:Handle uncaught errors below the root layout witherror.js.
• Optional:Handle granular uncaught errors with nestederror.jsfiles (e.g.app/dashboard/error.js)
• Uncommon:Handle uncaught errors in the root layout withglobal-error.js. ```
error.js
app/dashboard/error.js
global-error.js ### Using Error Boundaries Create an error boundary by adding anerror.tsxfile inside a route segment and exporting a React component: ```
'use client'// Error boundaries must be Client Componentsimport{ useEffect }from'react'exportdefaultfunctionError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {useEffect(()=>{// Log the error to an error reporting serviceconsole.error(error)},[error])return(<div><h2>Something went wrong!</h2><buttononClick={// Attempt to recover by trying to re-render the segment()=>reset()}>Try again</button></div>)}

================================================================================

# Route Handlers Route Handlers allow you to create custom request handlers for a given route using the WebRequestandResponseAPIs. Good to know: Route Handlers are only available inside theappdirectory. They are the equivalent ofAPI Routesinside thepagesdirectory meaning youdo notneed to use API Routes and Route Handlers together. ```
app
pages ## Convention Route Handlers are defined in aroute.js|tsfileinside theappdirectory: ```
route.js|ts
exportasyncfunctionGET(request:Request) {}
```Route Handlers can be nested anywhere inside theappdirectory, similar topage.jsandlayout.js. But therecannotbe aroute.jsfile at the same route segment level aspage.js. ```
page.js
layout.js
route.js ### Supported HTTP Methods ```
GET
POST
PUT
PATCH
DELETE
HEAD
OPTIONS
405 Method Not Allowed ### ExtendedNextRequestandNextResponseAPIs ```
NextRequest
NextResponse ## Behavior ### Caching Route Handlers are not cached by default. You can, however, opt into caching forGETmethods. Other supported HTTP methods arenotcached. To cache aGETmethod, use aroute config optionsuch asexport const dynamic = 'force-static'in your Route Handler file. ```
export const dynamic = 'force-static'
exportconstdynamic='force-static'exportasyncfunctionGET() {constres=awaitfetch('https://data.mongodb-api.com/...',{headers:{'Content-Type':'application/json','API-Key':process.env.DATAAPIKEY,},})constdata=awaitres.json()returnResponse.json({ data })}
```
sitemap.ts
opengraph-image.tsx
icon.tsx ### Route Resolution You can consider aroutethe lowest level routing primitive. ```
route
```• Theydo notparticipate in layouts or client-side navigations likepage.
• Therecannotbe aroute.jsfile at the same route aspage.js. ```
page
```
app/page.js | app/route.js | Conflict
app/page.js | app/api/route.js | Valid
app/[user]/page.js | app/api/route.js | Valid ```
app/page.js
app/route.js
app/api/route.js
app/[user]/page.js
```Eachroute.jsorpage.jsfile takes over all HTTP verbs for that route. ```
exportdefaultfunctionPage() {return<h1>Hello,Next.js!</h1>}// ❌ Conflict// `app/route.ts`exportasyncfunctionPOST(request:Request) {} ## Examples ### Revalidating Cached Data You canrevalidate cached datausing Incremental Static Regeneration (ISR): ```
exportconstrevalidate=60exportasyncfunctionGET() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()returnResponse.json(posts)} ### Cookies ```
cookies
next/headers
```
Response
Set-Cookie
import{ cookies }from'next/headers'exportasyncfunctionGET(request:Request) {constcookieStore=awaitcookies()consttoken=cookieStore.get('token')returnnewResponse('Hello, Next.js!',{status:200,headers:{'Set-Cookie':`token=${token.value}`},})}
import{typeNextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {consttoken=request.cookies.get('token')} ### Headers ```
headers
```Thisheadersinstance is read-only. To set headers, you need to return a newResponsewith newheaders. ```
import{ headers }from'next/headers'exportasyncfunctionGET(request:Request) {constheadersList=awaitheaders()constreferer=headersList.get('referer')returnnewResponse('Hello, Next.js!',{status:200,headers:{ referer:referer },})}
import{typeNextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {constrequestHeaders=newHeaders(request.headers)} ### Redirects ```
import{ redirect }from'next/navigation'exportasyncfunctionGET(request:Request) {redirect('https://nextjs.org/')} ### Dynamic Route Segments Route Handlers can useDynamic Segmentsto create request handlers from dynamic data. ```
exportasyncfunctionGET(request:Request,{ params }:{ params:Promise<{ slug:string}> }) {const{slug}=awaitparams// 'a', 'b', or 'c'}
```
app/items/[slug]/route.js | /items/a | Promise<{ slug: 'a' }>
app/items/[slug]/route.js | /items/b | Promise<{ slug: 'b' }>
app/items/[slug]/route.js | /items/c | Promise<{ slug: 'c' }> ```
params
app/items/[slug]/route.js
/items/a
Promise<{ slug: 'a' }>
/items/b
Promise<{ slug: 'b' }>
/items/c
Promise<{ slug: 'c' }> ### URL Query Parameters ```
import{typeNextRequest }from'next/server'exportfunctionGET(request:NextRequest) {constsearchParams=request.nextUrl.searchParamsconstquery=searchParams.get('query')// query is "hello" for /api/search?query=hello} ### Streaming Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about theAI SDK. ```
import{ openai }from'@ai-sdk/openai'import{ StreamingTextResponse,streamText }from'ai'exportasyncfunctionPOST(req:Request) {const{messages}=awaitreq.json()constresult=awaitstreamText({model:openai('gpt-4-turbo'),messages,})returnnewStreamingTextResponse(result.toAIStream())}
```These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly. ```
// https://developer.mozilla.org/docs/Web/API/ReadableStream#convertasynciteratortostreamfunctioniteratorToStream(iterator:any) {returnnewReadableStream({asyncpull(controller) {const{value,done}=awaititerator.next()if(done) {controller.close()}else{controller.enqueue(value)}},})}functionsleep(time:number) {returnnewPromise((resolve)=>{setTimeout(resolve,time)})}constencoder=newTextEncoder()asyncfunction*makeIterator() {yieldencoder.encode('<p>One</p>')awaitsleep(200)yieldencoder.encode('<p>Two</p>')awaitsleep(200)yieldencoder.encode('<p>Three</p>')}exportasyncfunctionGET() {constiterator=makeIterator()conststream=iteratorToStream(iterator)returnnewResponse(stream)} ### Request Body You can read theRequestbody using the standard Web API methods: ```
Request
exportasyncfunctionPOST(request:Request) {constres=awaitrequest.json()returnResponse.json({ res })} ### Request Body FormData You can read theFormDatausing therequest.formData()function: ```
FormData
request.formData()
exportasyncfunctionPOST(request:Request) {constformData=awaitrequest.formData()constname=formData.get('name')constemail=formData.get('email')returnResponse.json({ name,email })}
```
formData
zod-form-data
number ### CORS You can set CORS headers for a specific Route Handler using the standard Web API methods: ```
exportasyncfunctionGET(request:Request) {returnnewResponse('Hello, Next.js!',{status:200,headers:{'Access-Control-Allow-Origin':'*','Access-Control-Allow-Methods':'GET, POST, PUT, DELETE, OPTIONS','Access-Control-Allow-Headers':'Content-Type, Authorization',},})}
```Good to know: • To add CORS headers to multiple Route Handlers, you can useMiddlewareor thenext.config.jsfile.
• Alternatively, see ourCORS examplepackage. ```
next.config.js ### Webhooks You can use a Route Handler to receive webhooks from third-party services: ```
exportasyncfunctionPOST(request:Request) {try{consttext=awaitrequest.text()// Process the webhook payload}catch(error) {returnnewResponse(`Webhook error:${error.message}`,{status:400,})}returnnewResponse('Success!',{status:200,})}
```
bodyParser ### Non-UI Responses You can use Route Handlers to return non-UI content. Note thatsitemap.xml,robots.txt,app icons, andopen graph imagesall have built-in support. ```
sitemap.xml
robots.txt
app icons
exportasyncfunctionGET() {returnnewResponse(`<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0"><channel><title>Next.js Documentation</title><link>https://nextjs.org/docs</link><description>The React Framework for the Web</description></channel></rss>`,{headers:{'Content-Type':'text/xml',},})} ### Segment Config Options Route Handlers use the sameroute segment configurationas pages and layouts. ```
exportconstdynamic='auto'exportconstdynamicParams=trueexportconstrevalidate=falseexportconstfetchCache='auto'exportconstruntime='nodejs'exportconstpreferredRegion='auto'

================================================================================

# CSS • CSS Modules
• Global Styles
• External Stylesheets .module.css
```CSS Modules locally scope CSS by automatically creating a unique class name. This allows you to use the same class name in different files without worrying about collisions. This behavior makes CSS Modules the ideal way to include component-level CSS. ### Example CSS Modules can be imported into any file inside theappdirectory: ```
app
importstylesfrom'./styles.module.css'exportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return<sectionclassName={styles.dashboard}>{children}</section>}
.dashboard{padding:24px;}
```
.module.sass
```In production, all CSS Module files will be automatically concatenated intomany minified and code-split.cssfiles.
These.cssfiles represent hot execution paths in your application, ensuring the minimal amount of CSS is loaded for your application to paint. ```
.css Global styles can be imported into any layout, page, or component inside theappdirectory. Good to know: • This is different from thepagesdirectory, where you can only import global styles inside theapp.jsfile. ```
pages
app.js
```
app/global.css
body{padding:20px20px60px;max-width:680px;margin:0 auto;}
```Inside the root layout (app/layout.js), import theglobal.cssstylesheet to apply the styles to every route in your application: ```
app/layout.js
global.css
// These styles apply to every route in the applicationimport'./global.css'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{children}</body></html>)} Stylesheets published by external packages can be imported anywhere in theappdirectory, including colocated components: ```
import'bootstrap/dist/css/bootstrap.css'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><bodyclassName="container">{children}</body></html>)}
```
<link rel="stylesheet" /> ## Ordering and Merging For example,base-button.module.csswill be ordered beforepage.module.csssince<BaseButton>is imported first in<Page>: ```
base-button.module.css
page.module.css
<BaseButton>
<Page>
importstylesfrom'./base-button.module.css'exportfunctionBaseButton() {return<buttonclassName={styles.primary} />}
import{ BaseButton }from'./base-button'importstylesfrom'./page.module.css'exportdefaultfunctionPage() {return<BaseButtonclassName={styles.primary} />}
```To maintain a predictable order, we recommend the following: • Only import a CSS file in a single JS/TS file.If using global class names, import the global styles in the same file in the order you want them to be applied.
• Prefer CSS Modules over global styles.Use a consistent naming convention for your CSS modules. For example, using<name>.module.cssover<name>.tsx.
• Extract shared styles into a separate shared component.
• If usingTailwind, import the stylesheet at the top of the file, preferably in theRoot Layout.
• Turn off any linters/formatters (e.g., ESLint'ssort-import) that automatically sort your imports. This can inadvertently affect your CSS since CSS import ordermatters. • If using global class names, import the global styles in the same file in the order you want them to be applied. • Use a consistent naming convention for your CSS modules. For example, using<name>.module.cssover<name>.tsx. ```
<name>.module.css
<name>.tsx
sort-import
```
• You can use thecssChunkingoption innext.config.jsto control how CSS is chunked. ```
next build
cssChunking
next.config.js ## Additional Features • When running locally withnext dev, local stylesheets (either global or CSS modules) will take advantage ofFast Refreshto instantly reflect changes as edits are saved.
• When building for production withnext build, CSS files will be bundled into fewer minified.cssfiles to reduce the number of network requests needed to retrieve styles.
• If you disable JavaScript, styles will still be loaded in the production build (next start). However, JavaScript is still required fornext devto enableFast Refresh. ```
next dev
next start
================================================================================

================================================================================

# Tailwind CSS ## Installing Tailwind Install the necessary Tailwind CSS packages: ```
npminstall-Dtailwindcss@tailwindcss/postcsspostcss ## Configuring Tailwind Create apostcss.config.mjsfile in the root of your project and add the@tailwindcss/postcssplugin to your PostCSS configuration: ```
postcss.config.mjs
@tailwindcss/postcss
/**@type{import('tailwindcss').Config}*/exportdefault{plugins:{'@tailwindcss/postcss':{},},}
```As ofTailwind v4, there is zero configuration required by default. If you do need to configure Tailwind, you can follow theofficial documentationfor configuring the global CSS file. There is also anupgrade CLIandguideif you have an existing Tailwind v3 project. ## Importing Styles Add theTailwind CSS directivesthat Tailwind will use to inject its generated styles to aGlobal Stylesheetin your application, for example: ```
@import'tailwindcss';
```
app/layout.tsx
globals.css
importtype{ Metadata }from'next'// These styles apply to every route in the applicationimport'./globals.css'exportconstmetadata:Metadata={title:'Create Next App',description:'Generated by create next app',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang="en"><body>{children}</body></html>)} ## Using Classes After installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application. ```
exportdefaultfunctionPage() {return<h1className="text-3xl font-bold underline">Hello, Next.js!</h1>} ## Usage with Turbopack
================================================================================

================================================================================

# CSS-in-JS Warning:Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, includingconcurrent rendering. The following libraries are supported in Client Components in theappdirectory (alphabetical): ```
app
```• ant-design
• chakra-ui
• @fluentui/react-components
• kuma-ui
• @mui/material
• @mui/joy
• pandacss
• styled-jsx
• styled-components
• stylex
• tamagui
• tss-react
• vanilla-extract The following are currently working on support: • emotion Good to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or theappdirectory. If you want to style Server Components, we recommend usingCSS Modulesor other solutions that output CSS files, like PostCSS orTailwind CSS. ## Configuring CSS-in-JS inapp Configuring CSS-in-JS is a three-step opt-in process that involves: • Astyle registryto collect all CSS rules in a render.
• The newuseServerInsertedHTMLhook to inject rules before any content that might use them.
• A Client Component that wraps your app with the style registry during initial server-side rendering. ```
useServerInsertedHTML Usingstyled-jsxin Client Components requires usingv5.1.0. First, create a new registry: ```
v5.1.0
'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ StyleRegistry,createStyleRegistry }from'styled-jsx'exportdefaultfunctionStyledJsxRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[jsxStyleRegistry]=useState(()=>createStyleRegistry())useServerInsertedHTML(()=>{conststyles=jsxStyleRegistry.styles()jsxStyleRegistry.flush()return<>{styles}</>})return<StyleRegistryregistry={jsxStyleRegistry}>{children}</StyleRegistry>}
```
importStyledJsxRegistryfrom'./registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledJsxRegistry>{children}</StyledJsxRegistry></body></html>)}
```View an example here. ### Styled Components Below is an example of how to configurestyled-components@6or newer: ```
styled-components@6
next.config.js
module.exports={compiler:{styledComponents:true,},}
```
<head>
'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ ServerStyleSheet,StyleSheetManager }from'styled-components'exportdefaultfunctionStyledComponentsRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[styledComponentsStyleSheet]=useState(()=>newServerStyleSheet())useServerInsertedHTML(()=>{conststyles=styledComponentsStyleSheet.getStyleElement()styledComponentsStyleSheet.instance.clearTag()return<>{styles}</>})if(typeofwindow!=='undefined')return<>{children}</>return(<StyleSheetManagersheet={styledComponentsStyleSheet.instance}>{children}</StyleSheetManager>)}
```Wrap thechildrenof the root layout with the style registry component: ```
children
importStyledComponentsRegistryfrom'./lib/registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledComponentsRegistry>{children}</StyledComponentsRegistry></body></html>)}
```
================================================================================

================================================================================

# Redirecting API | Purpose | Where | Status Code
redirect | Redirect user after a mutation or event | Server Components, Server Actions, Route Handlers | 307 (Temporary) or 303 (Server Action)
permanentRedirect | Redirect user after a mutation or event | Server Components, Server Actions, Route Handlers | 308 (Permanent)
useRouter | Perform a client-side navigation | Event Handlers in Client Components | N/A
redirectsinnext.config.js | Redirect an incoming request based on a path | next.config.jsfile | 307 (Temporary) or 308 (Permanent)
NextResponse.redirect | Redirect an incoming request based on a condition | Middleware | Any ```
redirect
permanentRedirect
useRouter
redirects
next.config.js
NextResponse.redirect ## redirectfunction Theredirectfunction allows you to redirect the user to another URL. You can callredirectinServer Components,Route Handlers, andServer Actions. redirectis often used after a mutation or event. For example, creating a post: ```
'use server'import{ redirect }from'next/navigation'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost(id:string) {try{// Call database}catch(error) {// Handle errors}revalidatePath('/posts')// Update cached postsredirect(`/post/${id}`)// Navigate to the new post page}
```Good to know: • redirectinternally throws an error so it should be called outside oftry/catchblocks.
• redirectcan be called in Client Components during the rendering process but not in event handlers. You can use theuseRouterhookinstead.
• redirectalso accepts absolute URLs and can be used to redirect to external links.
• If you'd like to redirect before the render process, usenext.config.jsorMiddleware. ```
try/catch
```
'use server'import{ permanentRedirect }from'next/navigation'import{ revalidateTag }from'next/cache'exportasyncfunctionupdateUsername(username:string,formData:FormData) {try{// Call database}catch(error) {// Handle errors}revalidateTag('username')// Update all references to the usernamepermanentRedirect(`/profile/${username}`)// Navigate to the new user profile}
```• permanentRedirectreturns a 308 (permanent redirect) status code by default.
• permanentRedirectalso accepts absolute URLs and can be used to redirect to external links. See thepermanentRedirectAPI referencefor more information. ## useRouter()hook ```
useRouter()
```
push
'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype="button"onClick={()=>router.push('/dashboard')}>Dashboard</button>)}
```• If you don't need to programmatically navigate a user, you should use a<Link>component. ```
<Link>
```
importtype{ NextConfig }from'next'constnextConfig:NextConfig={asyncredirects() {return[// Basic redirect{source:'/about',destination:'/',permanent:true,},// Wildcard path matching{source:'/blog/:slug',destination:'/news/:slug',permanent:true,},]},}exportdefaultnextConfig
```See theredirectsAPI referencefor more information. • redirectscan return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with thepermanentoption.
• redirectsrunsbeforeMiddleware. ```
permanent ## NextResponse.redirectin Middleware For example, to redirect the user to a/loginpage if they are not authenticated: ```
/login
import{ NextResponse,NextRequest }from'next/server'import{ authenticate }from'auth-provider'exportfunctionmiddleware(request:NextRequest) {constisAuthenticated=authenticate(request)// If the user is authenticated, continue as normalif(isAuthenticated) {returnNextResponse.next()}// Redirect to login page if not authenticatedreturnNextResponse.redirect(newURL('/login',request.url))}exportconstconfig={matcher:'/dashboard/:path*',}
```
• Optimizing data lookup performance. ### 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: ```
{"/old":{"destination":"/new","permanent":true},"/blog/post-old":{"destination":"/blog/post-new","permanent":true}}
```InMiddleware, you can read from a database such as Vercel'sEdge ConfigorRedis, and redirect the user based on the incoming request: ```
import{ NextResponse,NextRequest }from'next/server'import{ get }from'@vercel/edge-config'typeRedirectEntry={destination:stringpermanent:boolean}exportasyncfunctionmiddleware(request:NextRequest) {constpathname=request.nextUrl.pathnameconstredirectData=awaitget(pathname)if(redirectData&&typeofredirectData==='string') {constredirectEntry:RedirectEntry=JSON.parse(redirectData)conststatusCode=redirectEntry.permanent?308:307returnNextResponse.redirect(redirectEntry.destination,statusCode)}// No redirect found, continue without redirectingreturnNextResponse.next()} ### 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: • Use a database that is optimized for fast reads, such asVercel Edge ConfigorRedis.
• Use a data lookup strategy such as aBloom filterto efficiently check if a redirect existsbeforereading the larger redirects file or database. If it does, forward the request to aRoute Handlerwhich will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Middleware, which can slow down every incoming request. ```
import{ NextResponse,NextRequest }from'next/server'import{ ScalableBloomFilter }from'bloom-filters'importGeneratedBloomFilterfrom'./redirects/bloom-filter.json'typeRedirectEntry={destination:stringpermanent:boolean}// Initialize bloom filter from a generated JSON fileconstbloomFilter=ScalableBloomFilter.fromJSON(GeneratedBloomFilterasany)exportasyncfunctionmiddleware(request:NextRequest) {// Get the path for the incoming requestconstpathname=request.nextUrl.pathname// Check if the path is in the bloom filterif(bloomFilter.has(pathname)) {// Forward the pathname to the Route Handlerconstapi=newURL(`/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,request.nextUrl.origin)try{// Fetch redirect data from the Route HandlerconstredirectData=awaitfetch(api)if(redirectData.ok) {constredirectEntry:RedirectEntry|undefined=awaitredirectData.json()if(redirectEntry) {// Determine the status codeconststatusCode=redirectEntry.permanent?308:307// Redirect to the destinationreturnNextResponse.redirect(redirectEntry.destination,statusCode)}}}catch(error) {console.error(error)}}// No redirect found, continue the request without redirectingreturnNextResponse.next()}
```
import{ NextRequest,NextResponse }from'next/server'importredirectsfrom'@/app/redirects/redirects.json'typeRedirectEntry={destination:stringpermanent:boolean}exportfunctionGET(request:NextRequest) {constpathname=request.nextUrl.searchParams.get('pathname')if(!pathname) {returnnewResponse('Bad Request',{ status:400})}// Get the redirect entry from the redirects.json fileconstredirect=(redirectsasRecord<string,RedirectEntry>)[pathname]// Account for bloom filter false positivesif(!redirect) {returnnewResponse('No redirect',{ status:400})}// Return the redirect entryreturnNextResponse.json(redirect)}

================================================================================

# Middleware Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly. Middleware runs before cached content and routes are matched. SeeMatching Pathsfor more details. ## Use Cases Some common scenarios where Middleware is effective include: • Quick redirects after reading parts of the incoming request
• Rewriting to different pages based on A/B tests or experiments
• Modifying headers for all pages or a subset of pages Middleware isnota good fit for: • Slow data fetching
• Session management ## Convention Use the filemiddleware.ts(or.js) in the root of your project to define Middleware. For example, at the same level aspagesorapp, or insidesrcif applicable. ```
middleware.ts
.js
pages
app
src
```Note: While only onemiddleware.tsfile is supported per project, you can still organize your middleware logic modularly. Break out middleware functionalities into separate.tsor.jsfiles and import them into your mainmiddleware.tsfile. This allows for cleaner management of route-specific middleware, aggregated in themiddleware.tsfor centralized control. By enforcing a single middleware file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple middleware layers. ```
.ts ## Example ```
import{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'// This function can be marked `async` if using `await` insideexportfunctionmiddleware(request:NextRequest) {returnNextResponse.redirect(newURL('/home',request.url))}// See "Matching Paths" below to learn moreexportconstconfig={matcher:'/about/:path*',} ## Matching Paths Middleware will be invoked forevery route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order: • headersfromnext.config.js
• redirectsfromnext.config.js
• Middleware (rewrites,redirects, etc.)
• beforeFiles(rewrites) fromnext.config.js
• Filesystem routes (public/,next/static/,pages/,app/, etc.)
• afterFiles(rewrites) fromnext.config.js
• Dynamic Routes (/blog/[slug])
• fallback(rewrites) fromnext.config.js ```
headers
next.config.js
redirects
rewrites
beforeFiles
public/
next/static/
pages/
app/
afterFiles
/blog/[slug]
fallback
```
• Conditional statements ### Matcher matcherallows you to filter Middleware to run on specific paths. ```
matcher
exportconstconfig={matcher:'/about/:path*',}
```You can match a single path or multiple paths with an array syntax: ```
exportconstconfig={matcher:['/about/:path*','/dashboard/:path*'],}
```
exportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - next/static (static files)* - next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/'/((?!api|next/static|next/image|favicon.ico|sitemap.xml|robots.txt).*)',],}
```You can also bypass Middleware for certain requests by using themissingorhasarrays, or a combination of both: ```
missing
has
exportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - next/static (static files)* - next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/{source:'/((?!api|next/static|next/image|favicon.ico|sitemap.xml|robots.txt).*)',missing:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|next/static|next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|next/static|next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'x-present'}],missing:[{ type:'header',key:'x-missing',value:'prefetch'}],},],}
```
• Can include named parameters:/about/:pathmatches/about/aand/about/bbut not/about/a/c
• Can have modifiers on named parameters (starting with:):/about/:path*matches/about/a/b/cbecause*iszero or more.?iszero or oneand+one or more
• Can use regular expression enclosed in parenthesis:/about/(.*)is the same as/about/:path* ```
/about/:path
/about/a
/about/b
/about/a/c
/about/:path*
/about/a/b/c
/about/(.*)
```Read more details onpath-to-regexpdocumentation. ```
/public
/public/index
/public/:path ### Conditional Statements ```
import{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {if(request.nextUrl.pathname.startsWith('/about')) {returnNextResponse.rewrite(newURL('/about-2',request.url))}if(request.nextUrl.pathname.startsWith('/dashboard')) {returnNextResponse.rewrite(newURL('/dashboard/user',request.url))}} ## NextResponse • redirectthe incoming request to a different URL
• rewritethe response by displaying a given URL
• Set request headers for API Routes,getServerSideProps, andrewritedestinations
• Set response cookies
• Set response headers ```
redirect
rewrite
getServerSideProps
```
• return aNextResponsedirectly. SeeProducing a Response ## Using Cookies ```
Request
Cookie
Response
Set-Cookie
cookies
NextRequest
```• For incoming requests,cookiescomes with the following methods:get,getAll,set, anddeletecookies. You can check for the existence of a cookie withhasor remove all cookies withclear.
• For outgoing responses,cookieshave the following methodsget,getAll,set, anddelete. ```
get
getAll
set
delete
clear
import{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Assume a "Cookie:nextjs=fast" header to be present on the incoming request// Getting cookies from the request using the `RequestCookies` APIletcookie=request.cookies.get('nextjs')console.log(cookie)// => { name: 'nextjs', value: 'fast', Path: '/' }constallCookies=request.cookies.getAll()console.log(allCookies)// => [{ name: 'nextjs', value: 'fast' }]request.cookies.has('nextjs')// => truerequest.cookies.delete('nextjs')request.cookies.has('nextjs')// => false// Setting cookies on the response using the `ResponseCookies` APIconstresponse=NextResponse.next()response.cookies.set('vercel','fast')response.cookies.set({name:'vercel',value:'fast',path:'/',})cookie=response.cookies.get('vercel')console.log(cookie)// => { name: 'vercel', value: 'fast', Path: '/' }// The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.returnresponse} ## Setting Headers ```
import{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Clone the request headers and set a new header `x-hello-from-middleware1`constrequestHeaders=newHeaders(request.headers)requestHeaders.set('x-hello-from-middleware1','hello')// You can also set request headers in NextResponse.nextconstresponse=NextResponse.next({request:{// New request headersheaders:requestHeaders,},})// Set a new response header `x-hello-from-middleware2`response.headers.set('x-hello-from-middleware2','hello')returnresponse}
```
import{ NextRequest,NextResponse }from'next/server'constallowedOrigins=['https://acme.com','https://my-app.org']constcorsOptions={'Access-Control-Allow-Methods':'GET, POST, PUT, DELETE, OPTIONS','Access-Control-Allow-Headers':'Content-Type, Authorization',}exportfunctionmiddleware(request:NextRequest) {// Check the origin from the requestconstorigin=request.headers.get('origin')??''constisAllowedOrigin=allowedOrigins.includes(origin)// Handle preflighted requestsconstisPreflight=request.method==='OPTIONS'if(isPreflight) {constpreflightHeaders={...(isAllowedOrigin&&{'Access-Control-Allow-Origin':origin }),...corsOptions,}returnNextResponse.json({},{ headers:preflightHeaders })}// Handle simple requestsconstresponse=NextResponse.next()if(isAllowedOrigin) {response.headers.set('Access-Control-Allow-Origin',origin)}Object.entries(corsOptions).forEach(([key,value])=>{response.headers.set(key,value)})returnresponse}exportconstconfig={matcher:'/api/:path*',}
```Good to know:You can configure CORS headers for individual routes inRoute Handlers. ## Producing a Response ```
importtype{ NextRequest }from'next/server'import{ isAuthenticated }from'@lib/auth'// Limit the middleware to paths starting with `/api/`exportconstconfig={matcher:'/api/:function*',}exportfunctionmiddleware(request:NextRequest) {// Call our authentication function to check the requestif(!isAuthenticated(request)) {// Respond with JSON indicating an error messagereturnResponse.json({ success:false,message:'authentication failed'},{ status:401})}} ### waitUntilandNextFetchEvent ```
waitUntil
NextFetchEvent
FetchEvent
waitUntil()
```
import{ NextResponse }from'next/server'importtype{ NextFetchEvent,NextRequest }from'next/server'exportfunctionmiddleware(req:NextRequest,event:NextFetchEvent) {event.waitUntil(fetch('https://my-analytics-platform.com',{method:'POST',body:JSON.stringify({ pathname:req.nextUrl.pathname }),}))returnNextResponse.next()} ## Advanced Middleware Flags ```
v13.1
skipMiddlewareUrlNormalize
skipTrailingSlashRedirect
module.exports={skipTrailingSlashRedirect:true,}
constlegacyPrefixes=['/docs','/blog']exportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrlif(legacyPrefixes.some((prefix)=>pathname.startsWith(prefix))) {returnNextResponse.next()}// apply trailing slash handlingif(!pathname.endsWith('/')&&!pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)) {returnNextResponse.redirect(newURL(`${req.nextUrl.pathname}/`,req.nextUrl))}}
module.exports={skipMiddlewareUrlNormalize:true,}
exportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrl// GET /next/data/build-id/hello.jsonconsole.log(pathname)// with the flag this now /next/data/build-id/hello.json// without the flag this would be normalized to /hello} ## Unit Testing (experimental) ```
next/experimental/testing/server
```TheunstabledoesMiddlewareMatchfunction can be used to assert whether middleware will run for the provided URL, headers, and cookies. ```
unstabledoesMiddlewareMatch
import{ unstabledoesMiddlewareMatch }from'next/experimental/testing/server'expect(unstabledoesMiddlewareMatch({config,nextConfig,url:'/test',})).toEqual(false)
```
import{ isRewrite,getRewrittenUrl }from'next/experimental/testing/server'constrequest=newNextRequest('https://nextjs.org/docs')constresponse=awaitmiddleware(request)expect(isRewrite(response)).toEqual(true)expect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')// getRedirectUrl could also be used if the response were a redirect ## Runtime ```
next.config
importtype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{nodeMiddleware:true,},}exportdefaultnextConfig

================================================================================

# Route Segment Config The options outlined on this page are disabled if thedynamicIOflag is on, and will eventually be deprecated in the future. ```
dynamicIO
```The Route Segment options allows you to configure the behavior of aPage,Layout, orRoute Handlerby directly exporting the following variables: Option | Type | Default
experimentalppr | boolean | dynamic | 'auto' | 'force-dynamic' | 'error' | 'force-static' | 'auto'
dynamicParams | boolean | true
revalidate | false | 0 | number | false
fetchCache | 'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store' | 'auto'
runtime | 'nodejs' | 'edge' | 'nodejs'
preferredRegion | 'auto' | 'global' | 'home' | string | string[] | 'auto'
maxDuration | number | Set by deployment platform ```
experimentalppr
boolean
dynamic
'auto' | 'force-dynamic' | 'error' | 'force-static'
'auto'
dynamicParams
true
revalidate
false | 0 | number
false
fetchCache
'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'
runtime
'nodejs' | 'edge'
'nodejs'
preferredRegion
'auto' | 'global' | 'home' | string | string[]
maxDuration
number ## Options EnablePartial Prerendering (PPR)for a layout or page. ```
exportconstexperimental_ppr=true// true | false Change the dynamic behavior of a layout or page to fully static or fully dynamic. ```
exportconstdynamic='auto'// 'auto' | 'force-dynamic' | 'error' | 'force-static'
app
fetch
getServerSideProps
getStaticProps
pages
```
• 'force-static': Force static rendering and cache the data of a layout or page by forcingcookies,headers()anduseSearchParams()to return empty values. 'force-dynamic': Forcedynamic rendering, which will result in routes being rendered for each user at request time. This option is equivalent to: ```
'force-dynamic'
```• Setting the option of everyfetch()request in a layout or page to{ cache: 'no-store', next: { revalidate: 0 } }.
• Setting the segment config toexport const fetchCache = 'force-no-store' ```
fetch()
{ cache: 'no-store', next: { revalidate: 0 } }
export const fetchCache = 'force-no-store'
```
'error'
```• getStaticProps()in thepagesdirectory.
• Setting the option of everyfetch()request in a layout or page to{ cache: 'force-cache' }.
• Setting the segment config tofetchCache = 'only-cache', dynamicParams = false. ```
getStaticProps()
{ cache: 'force-cache' }
fetchCache = 'only-cache', dynamicParams = false
dynamic = 'error'
generateStaticParams
dynamicParams = true
'force-static'
cookies
headers()
useSearchParams()
```
dynamic: 'force-dynamic'
dynamic: 'error' Control what happens when a dynamic segment is visited that was not generated withgenerateStaticParams. ```
exportconstdynamicParams=true// true | false,
```• true(default): Dynamic segments not included ingenerateStaticParamsare generated on demand.
• false: Dynamic segments not included ingenerateStaticParamswill return a 404. • This option replaces thefallback: true | false | blockingoption ofgetStaticPathsin thepagesdirectory.
• To statically render all paths the first time they're visited, you'll need to return an empty array ingenerateStaticParamsor utilizeexport const dynamic = 'force-static'.
• WhendynamicParams = true, the segment usesStreaming Server Rendering.
• If thedynamic = 'error'anddynamic = 'force-static'are used, it'll change the default ofdynamicParamstofalse. ```
fallback: true | false | blocking
getStaticPaths
export const dynamic = 'force-static'
dynamic = 'force-static' Set the default revalidation time for a layout or page. This option does not override therevalidatevalue set by individualfetchrequests. ```
exportconstrevalidate=false// false | 0 | number
```
cache
'force-cache'
revalidate: Infinity
cache: 'no-store'
revalidate: 0
'no-store'
```• The revalidate value needs to be statically analyzable. For examplerevalidate = 600is valid, butrevalidate = 60 * 10is not.
• The revalidate value is not available when usingruntime = 'edge'.
• In Development, Pages arealwaysrendered on-demand and are never cached. This allows you to see changes immediately without waiting for a revalidation period to pass. ```
revalidate = 600
revalidate = 60 * 10
runtime = 'edge' #### Revalidation Frequency fetchCacheallows you to override the defaultcacheoption of allfetchrequests in a layout or page. ```
exportconstfetchCache='auto'// 'auto' | 'default-cache' | 'only-cache'// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'
```
• 'only-cache': Ensure allfetchrequests opt into caching by changing the default tocache: 'force-cache'if no option is provided and causing an error if anyfetchrequests usecache: 'no-store'.
• 'force-cache': Ensure allfetchrequests opt into caching by setting thecacheoption of allfetchrequests to'force-cache'.
• 'only-no-store': Ensure allfetchrequests opt out of caching by changing the default tocache: 'no-store'if no option is provided and causing an error if anyfetchrequests usecache: 'force-cache' ```
'default-cache'
'only-cache'
cache: 'force-cache'
'default-no-store'
'only-no-store'
'force-no-store' #### Cross-route segment behavior • It is generally recommended to leave shared parent layouts as'auto'and customize the options where child segments diverge. • A parent cannot provide'default-no-store'if a child provides'auto'or'*-cache'since that could make the same fetch have different behavior. ```
'force-*'
'only-*'
```• A combination of'only-cache'and'only-no-store'in a single route is not allowed.
• A combination of'force-cache'and'force-no-store'in a single route is not allowed. ```
'*-cache' We recommend using the Node.js runtime for rendering your application, and the Edge runtime for Middleware (only supported option). ```
exportconstruntime='nodejs'// 'nodejs' | 'edge'
```
• 'edge' Learn more about thedifferent runtimes. exportconstpreferredRegion='auto'// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']
```Support forpreferredRegion, and regions supported, is dependent on your deployment platform. • If apreferredRegionis not specified, it will inherit the option of the nearest parent layout.
• The root layout defaults toallregions. ```
all 13.4.10
exportconstmaxDuration=5
```
v15.0.0-RC | export const runtime = "experimental-edge"deprecated. Acodemodis available. ```
v15.0.0-RC
export const runtime = "experimental-edge"
================================================================================

================================================================================

# API Reference ### Directives ### Components ### File Conventions ### Functions ### Configuration ### CLI ### Edge Runtime ### Turbopack
================================================================================

================================================================================

# Sass ```
.scss
.sass
.module.scss
.module.sass
```First, installsass: ```
sass
npminstall--save-devsass
```
The.scssextension requires you use theSCSS syntax,
while the.sassextension requires you use theIndented Syntax ("Sass"). If you're not sure which to choose, start with the.scssextension which is a superset of CSS, and doesn't require you learn the
Indented Syntax ("Sass"). ### Customizing Sass Options ```
sassOptions
next.config
importtype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{additionalData:`$var: red;`,},}exportdefaultnextConfig #### Implementation ```
implementation
importtype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{implementation:'sass-embedded',},}exportdefaultnextConfig ### Sass Variables For example, using the exportedprimaryColorSass variable: ```
primaryColor
$primary-color:#64ff00;:export {primaryColor:$primary-color;}
// maps to root `/` URLimportvariablesfrom'./variables.module.scss'exportdefaultfunctionPage() {return<h1style={{ color:variables.primaryColor }}>Hello, Next.js!</h1>}
================================================================================

================================================================================

# Data Fetching and Caching • Next.js Commerce
• On-Demand ISR
• Next.js Forms ```
exportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}
```This example demonstrates a basic server-side data fetch using thefetchAPI in an asynchronous React Server Component. ```
fetch ## Reference • Reactcache
• Next.jsunstablecache ```
cache
unstablecache ## Examples ### Fetching data on the server with thefetchAPI This component will fetch and display a list of blog posts. The response fromfetchis not cached by default. ```
next build
```
exportconstdynamic='force-dynamic'
cookies
headers
searchParams
force-dynamic ### Fetching data on the server with an ORM or database This component will fetch and display a list of blog posts. The response from the database is not cached by default but could be withadditional configuration. ```
import{ db,posts }from'@/lib/db'exportdefaultasyncfunctionPage() {constallPosts=awaitdb.select().from(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)} ### Fetching data on the client We recommend first attempting to fetch data on the server-side. However, there are still cases where client-side data fetching makes sense. In these scenarios, you can manually callfetchin auseEffect(not recommended), or lean on popular React libraries in the community (such asSWRorReact Query) for client fetching. ```
useEffect
'use client'import{ useState,useEffect }from'react'exportfunctionPosts() {const[posts,setPosts]=useState(null)useEffect(()=>{asyncfunctionfetchPosts() {constres=awaitfetch('https://api.vercel.app/blog')constdata=awaitres.json()setPosts(data)}fetchPosts()},[])if(!posts)return<div>Loading...</div>return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)} ### Caching data with an ORM or Database ```
import{ unstablecache }from'next/cache'import{ db,posts }from'@/lib/db'constgetPosts=unstablecache(async()=>{returnawaitdb.select().from(posts)},['posts'],{ revalidate:3600,tags:['posts'] })exportdefaultasyncfunctionPage() {constallPosts=awaitgetPosts()return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}
```This example caches the result of the database query for 1 hour (3600 seconds). It also adds the cache tagpostswhich can then be invalidated withIncremental Static Regeneration. ```
posts ### Reusing data across multiple functions ```
generateMetadata
generateStaticParams
page
```
cache: 'force-cache'
```Good to know: • In previous versions of Next.js, usingfetchwould have a defaultcachevalue offorce-cache. This changed in version 15, to a default ofcache: no-store. ```
force-cache
cache: no-store
import{ notFound }from'next/navigation'interfacePost{id:stringtitle:stringcontent:string}asyncfunctiongetPost(id:string) {constres=awaitfetch(`https://api.vercel.app/blog/${id}`,{cache:'force-cache',})constpost:Post=awaitres.json()if(!post)notFound()returnpost}exportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://api.vercel.app/blog',{cache:'force-cache',}).then((res)=>res.json())returnposts.map((post:Post)=>({id:String(post.id),}))}exportasyncfunctiongenerateMetadata({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return{title:post.title,}}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return(<article><h1>{post.title}</h1><p>{post.content}</p></article>)}
```
import{ cache }from'react'import{ db,posts,eq }from'@/lib/db'// Example with Drizzle ORMimport{ notFound }from'next/navigation'exportconstgetPost=cache(async(id)=>{constpost=awaitdb.query.posts.findFirst({where:eq(posts.id,parseInt(id)),})if(!post)notFound()returnpost}) ### Revalidating cached data Learn more about revalidating cached data withIncremental Static Regeneration. ## Patterns ### Parallel and sequential data fetching When fetching data inside components, you need to be aware of two data fetching patterns: Parallel and Sequential. • Sequential: requests in a component tree are dependent on each other. This can lead to longer loading times.
• Parallel: requests in a route are eagerly initiated and will load data at the same time. This reduces the total time it takes to load data. #### Sequential data fetching If you have nested components, and each component fetches its own data, then data fetching will happen sequentially if those data requests are notmemoized. There may be cases where you want this pattern because one fetch depends on the result of the other. For example, thePlaylistscomponent will only start fetching data once theArtistcomponent has finished fetching data becausePlaylistsdepends on theartistIDprop: ```
Playlists
Artist
artistID
exportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparams// Getartistinformationconstartist=awaitgetArtist(username)return(<><h1>{artist.name}</h1>{/* Show fallback UI while the Playlists component is loading */}<Suspensefallback={<div>Loading...</div>}>{/* Pass theartistID to the Playlists component */}<PlaylistsartistID={artist.id} /></Suspense></>)}asyncfunctionPlaylists({artistID }:{artistID:string}) {// Use theartistID to fetch playlistsconstplaylists=awaitgetArtistPlaylists(artistID)return(<ul>{playlists.map((playlist)=>(<likey={playlist.id}>{playlist.name}</li>))}</ul>)}
loading.js
<Suspense>
```This will prevent the whole route from being blocked by data requests, and the user will be able to interact with the parts of the page that are ready. #### Parallel Data Fetching By default, layout and page segments are rendered in parallel. This means requests will be initiated in parallel. However, due to the nature ofasync/await, an awaited request inside the same segment or component will block any requests below it. ```
async
await
```
getArtist
getAlbums
Page
Promise.all
importAlbumsfrom'./albums'asyncfunctiongetArtist(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}`)returnres.json()}asyncfunctiongetAlbums(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}/albums`)returnres.json()}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparamsconstartistData=getArtist(username)constalbumsData=getAlbums(username)// Initiate both requests in parallelconst[artist,albums]=awaitPromise.all([artistData,albumsData])return(<><h1>{artist.name}</h1><Albumslist={albums} /></>)}
```In addition, you can add aSuspense Boundaryto break up the rendering work and show part of the result as soon as possible. ### Preloading Data Another way to prevent waterfalls is to use thepreloadpattern by creating an utility function that you eagerly call above blocking requests. For example,checkIsAvailable()blocks<Item/>from rendering, so you can callpreload()before it to eagerly initiate<Item/>data dependencies. By the time<Item/>is rendered, its data has already been fetched. ```
checkIsAvailable()
<Item/>
preload()
```
preload
import{ getItem }from'@/utils/get-item'exportconstpreload=(id:string)=>{// void evaluates the given expression and returns undefined// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/voidvoidgetItem(id)}exportdefaultasyncfunctionItem({ id }:{ id:string}) {constresult=awaitgetItem(id)// ...}
importItem,{ preload,checkIsAvailable }from'@/components/Item'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparams// starting loadingitemdatapreload(id)// perform another asynchronous taskconstisAvailable=awaitcheckIsAvailable()returnisAvailable?<Itemid={id} />:null}
```Good to know:The "preload" function can also have any name as it's a pattern, not an API. #### Using Reactcacheandserver-onlywith the Preload Pattern ```
server-only
```
import{ cache }from'react'import'server-only'exportconstpreload=(id:string)=>{voidgetItem(id)}exportconstgetItem=cache(async(id:string)=>{// ...})
```With this approach, you can eagerly fetch data, cache responses, and guarantee that this data fetchingonly happens on the server. Theutils/get-itemexports can be used by Layouts, Pages, or other components to give them control over when an item's data is fetched. ```
utils/get-item
```
taintObjectReference
taintUniqueValue
experimental.taint
true
module.exports={experimental:{taint:true,},}

================================================================================

# Incremental Static Regeneration (ISR) • Next.js Commerce
• On-Demand ISR
• Next.js Forms Incremental Static Regeneration (ISR) enables you to: • Update static content without rebuilding the entire site
• Reduce server load by serving prerendered, static pages for most requests
• Ensure propercache-controlheaders are automatically added to pages
• Handle large amounts of content pages without longnext buildtimes ```
cache-control
next build
```Here's a minimal example: ```
interfacePost{id:stringtitle:stringcontent:string}// Next.js will invalidate the cache when a// request comes in, at most once every 60 seconds.exportconstrevalidate=60// We'll prerender only the params from `generateStaticParams` at build time.// If a request comes in for a path that hasn't been generated,// Next.js will server-render the page on-demand.exportconstdynamicParams=true// or false, to 404 on unknown pathsexportasyncfunctiongenerateStaticParams() {constposts:Post[]=awaitfetch('https://api.vercel.app/blog').then((res)=>res.json())returnposts.map((post)=>({id:String(post.id),}))}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost:Post=awaitfetch(`https://api.vercel.app/blog/${id}`).then((res)=>res.json())return(<main><h1>{post.title}</h1><p>{post.content}</p></main>)}
```
• All requests made to these pages (e.g./blog/1) are cached and instantaneous
• After 60 seconds has passed, the next request will still show the cached (stale) page
• The cache is invalidated and a new version of the page begins generating in the background
• Once generated successfully, Next.js will display and cache the updated page
• If/blog/26is requested, Next.js will generate and cache this page on-demand ```
/blog/1
/blog/26 ## Reference ### Route segment config • revalidate
• dynamicParams ### Functions • revalidatePath
• revalidateTag ## Examples ### Time-based revalidation ```
/blog
interfacePost{id:stringtitle:stringcontent:string}exportconstrevalidate=3600// invalidate every hourexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts:Post[]=awaitdata.json()return(<main><h1>Blog Posts</h1><ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul></main>)}
```We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching todynamic rendering. ### On-demand revalidation withrevalidatePath For a more precise method of revalidation, invalidate pages on-demand with therevalidatePathfunction. For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either usingfetchor connecting to a database, this will clear the cache for the entire route and allow the Server Component to fetch fresh data. ```
fetch
'use server'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost() {// Invalidate the /posts route in the cacherevalidatePath('/posts')}
```
exportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog',{next:{ tags:['posts'] },})constposts=awaitdata.json()// ...}
```If you are using an ORM or connecting to a database, you can useunstablecache: ```
unstablecache
import{ unstablecache }from'next/cache'import{ db,posts }from'@/lib/db'constgetCachedPosts=unstablecache(async()=>{returnawaitdb.select().from(posts)},['posts'],{ revalidate:3600,tags:['posts'] })exportdefaultasyncfunctionPage() {constposts=getCachedPosts()// ...}
```
'use server'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost() {// Invalidate all data tagged with 'posts' in the cacherevalidateTag('posts')} ### Handling uncaught exceptions ### Customizing the cache location Caching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. Whendeploying to Vercel, the ISR cache is automatically persisted to durable storage. ## Troubleshooting ### Debugging cached data in local development If you are using thefetchAPI, you can add additional logging to understand which requests are cached or uncached.Learn more about theloggingoption. ```
logging
module.exports={logging:{fetches:{fullUrl:true,},},} ### Verifying correct production behavior ```
next start

================================================================================

# Next.js Compiler ## Why SWC? We chose to build on SWC for a few reasons: • Extensibility:SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.
• Performance:We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.
• WebAssembly:Rust's support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.
• Community:The Rust community and ecosystem are amazing and still growing. ## Supported Features ### Styled Components ```
babel-plugin-styled-components
npm install next@latest
next.config.js
module.exports={compiler:{styledComponents:true,},}
```For advanced use cases, you can configure individual properties for styled-components compilation. ```
ssr
displayName
styled-components
module.exports={compiler:{// see https://styled-components.com/docs/tooling#babel-plugin for more info on the options.styledComponents:{// Enabled by default in development, disabled in production to reduce file size,// setting this will override the default for all environments.displayName?:boolean,// Enabled by default.ssr?:boolean,// Enabled by default.fileName?:boolean,// Empty by default.topLevelImportPaths?:string[],// Defaults to ["index"].meaninglessFileNames?:string[],// Enabled by default.minify?:boolean,// Enabled by default.transpileTemplateLiterals?:boolean,// Empty by default.namespace?:string,// Disabled by default.pure?:boolean,// Enabled by default.cssProp?:boolean,},},} ### Jest • Auto mocking of.css,.module.css(and their.scssvariants), and image imports
• Automatically sets uptransformusing SWC
• Loading.env(and all variants) intoprocess.env
• Ignoresnodemodulesfrom test resolving and transforms
• Ignoring.nextfrom test resolving
• Loadsnext.config.jsfor flags that enable experimental SWC transforms ```
.css
.module.css
.scss
transform
.env
process.env
nodemodules
.next
jest.config.js
constnextJest=require('next/jest')// Providing the path to your Next.js app which will enable loading next.config.js and .env filesconstcreateJestConfig=nextJest({ dir:'./'})// Any custom config you want to pass to JestconstcustomJestConfig={setupFilesAfterEnv:['<rootDir>/jest.setup.js'],}// createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is asyncmodule.exports=createJestConfig(customJestConfig) ### Relay To enableRelaysupport: ```
module.exports={compiler:{relay:{// This should match relay.config.jssrc:'./',artifactDirectory:'./generated',language:'typescript',eagerEsModules:false,},},}
pages
relay-compiler
artifactDirectory
generated ### Remove React Properties Allows to remove JSX properties. This is often used for testing. Similar tobabel-plugin-react-remove-properties. ```
babel-plugin-react-remove-properties
```
^data-test
module.exports={compiler:{reactRemoveProperties:true,},}
```To remove custom properties: ```
module.exports={compiler:{// The regexes defined here are processed in Rust so the syntax is different from// JavaScript `RegExp`s. See https://docs.rs/regex.reactRemoveProperties:{ properties:['^data-custom$'] },},} ### Remove Console This transform allows for removing allconsole.*calls in application code (notnode_modules). Similar tobabel-plugin-transform-remove-console. ```
console.*
babel-plugin-transform-remove-console
```
module.exports={compiler:{removeConsole:true,},}
```Removeconsole.*output exceptconsole.error: ```
console.error
module.exports={compiler:{removeConsole:{exclude:['error'],},},} ### Legacy Decorators ```
experimentalDecorators
jsconfig.json
tsconfig.json
mobx
```
{"compilerOptions": {"experimentalDecorators":true}} ### importSource ```
jsxImportSource
{"compilerOptions": {"jsxImportSource":"theme-ui"}} ### Emotion ```
@emotion/babel-plugin
module.exports={compiler:{emotion:boolean|{// default is true. It will be disabled when build type is production.sourceMap?:boolean,// default is 'dev-only'.autoLabel?:'never'|'dev-only'|'always',// default is '[local]'.// Allowed values: `[local]` `[filename]` and `[dirname]`// This option only works when autoLabel is set to 'dev-only' or 'always'.// It allows you to define the format of the resulting label.// The format is defined via string where variable parts are enclosed in square brackets [].// For example labelFormat: "my-classname--[local]", where [local] will be replaced with the name of the variable the result is assigned to.labelFormat?:string,// default is undefined.// This option allows you to tell the compiler what imports it should// look at to determine what it should transform so if you re-export// Emotion's exports, you can still use transforms.importMap?:{[packageName: string]:{[exportName: string]:{canonicalImport?:[string,string],styledBaseImport?:[string,string],}}},},},} ### Minification ```
swcMinify ### Module Transpilation ```
next-transpile-modules
module.exports={transpilePackages:['@acme/ui','lodash-es'],} ### Modularize Imports ```
optimizePackageImports ### Define (Replacing variables during build) Thedefineoption allows you to statically replace variables in your code at build-time.
The option takes an object as key-value pairs, where the keys are the variables that should be replaced with the corresponding values. ```
define
compiler.define
module.exports={compiler:{define:{MYSTRINGVARIABLE:JSON.stringify('my-string'),MYNUMBERVARIABLE:'42',},},} ## Experimental Features ### SWC Trace profiling You can generate SWC's internal transform traces as chromium'strace event format. ```
module.exports={experimental:{swcTraceProfiling:true,},}
swc-trace-profile-${timestamp}.json
.next/ ### SWC Plugins (experimental) You can configure swc's transform to use SWC's experimental plugin support written in wasm to customize transformation behavior. ```
module.exports={experimental:{swcPlugins:[['plugin',{...pluginOptions,},],],},}
```swcPluginsaccepts an array of tuples for configuring plugins. A tuple for the plugin contains the path to the plugin and an object for plugin configuration. The path to the plugin can be an npm module package name or an absolute path to the.wasmbinary itself. ```
swcPlugins
.wasm ## Unsupported Features ```
.babelrc
```
v13.1.0 | Module TranspilationandModularize Importsstable.
v13.0.0 | SWC Minifier enabled by default.
v12.3.0 | SWC Minifierstable.
v12.2.0 | SWC Pluginsexperimental support added.
v12.1.0 | Added support for Styled Components, Jest, Relay, Remove React Properties, Legacy Decorators, Remove Console, and jsxImportSource.
v12.0.0 | Next.js Compilerintroduced. ```
v13.1.0
v13.0.0
v12.3.0
v12.2.0
v12.1.0
v12.0.0
================================================================================

================================================================================

# Server Actions and Mutations 🎥 Watch:Learn more about mutations with Server Actions YouTube (10 minutes). ## Convention A Server Action can be defined with the React"use server"directive. You can place the directive at the top of anasyncfunction to mark the function as a Server Action, or at the top of a separate file to mark all exports of that file as Server Actions. ```
"use server"
async ### Server Components Server Components can use the inline function level or module level"use server"directive. To inline a Server Action, add"use server"to the top of the function body: ```
exportdefaultfunctionPage() {// Server Actionasyncfunctioncreate() {'use server'// Mutate data}return'...'} ### Client Components To call a Server Action in a Client Component, create a new file and add the"use server"directive at the top of it. All exported functions within the file will be marked as Server Actions that can be reused in both Client and Server Components: ```
'use server'exportasyncfunctioncreate() {}
'use client'import{ create }from'./actions'exportfunctionButton() {return<buttononClick={()=>create()}>Create</button>} ### Passing actions as props You can also pass a Server Action to a Client Component as a prop: ```
<ClientComponentupdateItemAction={updateItem} />
'use client'exportdefaultfunctionClientComponent({updateItemAction,}:{updateItemAction:(formData:FormData)=>void}) {return<formaction={updateItemAction}>{/* ... */}</form>}
updateItemAction
client-component.tsx
action
Action ## Behavior • Server Actions are not limited to<form>and can be invoked from event handlers,useEffect, third-party libraries, and other form elements like<button>.
• Server Actions integrate with the Next.jscaching and revalidationarchitecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip.
• Behind the scenes, actions use thePOSTmethod, and only this HTTP method can invoke them.
• The arguments and return value of Server Actions must be serializable by React. See the React docs for a list ofserializable arguments and values.
• Server Actions are functions. This means they can be reused anywhere in your application.
• Server Actions inherit theruntimefrom the page or layout they are used on.
• Server Actions inherit theRoute Segment Configfrom the page or layout they are used on, including fields likemaxDuration. ```
<form>
```• Server Components support progressive enhancement by default, meaning the form will be submitted even if JavaScript hasn't loaded yet or is disabled.
• In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, prioritizing client hydration.
• After hydration, the browser does not refresh on form submission. ```
useEffect
<button>
POST
maxDuration ## Examples ### Forms React extends the HTML<form>element to allow Server Actions to be invoked with theactionprop. When invoked in a form, the action automatically receives theFormDataobject. You don't need to use ReactuseStateto manage fields, instead, you can extract the data using the nativeFormDatamethods: ```
FormData
useState
exportdefaultfunctionPage() {asyncfunctioncreateInvoice(formData:FormData) {'use server'constrawFormData={customerId:formData.get('customerId'),amount:formData.get('amount'),status:formData.get('status'),}// mutate data// revalidate cache}return<formaction={createInvoice}>...</form>}
```
• SeeReact<form>documentationto learn more. ```
entries()
Object.fromEntries()
const rawFormData = Object.fromEntries(formData)
formData
$ACTION_ ### Passing additional arguments You can pass additional arguments to a Server Action using the JavaScriptbindmethod. ```
bind
'use client'import{ updateUser }from'./actions'exportfunctionUserProfile({ userId }:{ userId:string}) {constupdateUserWithId=updateUser.bind(null,userId)return(<formaction={updateUserWithId}><inputtype="text"name="name"/><buttontype="submit">Update User Name</button></form>)}
```The Server Action will receive theuserIdargument, in addition to the form data: ```
userId
'use server'exportasyncfunctionupdateUser(userId:string,formData:FormData) {}
```
<input type="hidden" name="userId" value={userId} />
.bind ### Nested form elements You can also invoke a Server Action in elements nested inside<form>such as<button>,<input type="submit">, and<input type="image">. These elements accept theformActionprop orevent handlers. ```
<input type="submit">
<input type="image">
formAction
```This is useful in cases where you want to call multiple server actions within a form. For example, you can create a specific<button>element for saving a post draft in addition to publishing it. See theReact<form>docsfor more information. ### Programmatic form submission You can trigger a form submission programmatically using therequestSubmit()method. For example, when the user submits a form using the⌘+Enterkeyboard shortcut, you can listen for theonKeyDownevent: ```
requestSubmit()
Enter
onKeyDown
'use client'exportfunctionEntry() {consthandleKeyDown=(e:React.KeyboardEvent<HTMLTextAreaElement>)=>{if((e.ctrlKey||e.metaKey)&&(e.key==='Enter'||e.key==='NumpadEnter')) {e.preventDefault()e.currentTarget.form?.requestSubmit()}}return(<div><textareaname="entry"rows={20}requiredonKeyDown={handleKeyDown} /></div>)}
```
required
type="email"
```For more advanced server-side validation, you can use a library likezodto validate the form fields before mutating the data: ```
'use server'import{ z }from'zod'constschema=z.object({email:z.string({invalidtypeerror:'Invalid Email',}),})exportdefaultasyncfunctioncreateUser(formData:FormData) {constvalidatedFields=schema.safeParse({email:formData.get('email'),})// Return early if the form data is invalidif(!validatedFields.success) {return{errors:validatedFields.error.flatten().fieldErrors,}}// Mutate data}
```
useActionState
```• By passing the action touseActionState, the action's function signature changes to receive a newprevStateorinitialStateparameter as its first argument.
• useActionStateis a React Hook and therefore must be used in a Client Component. ```
prevState
initialState
'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreateUser(prevState:any,formData:FormData) {constres=awaitfetch('https://...')constjson=awaitres.json()if(!res.ok) {return{ message:'Please enter a valid email'}}redirect('/dashboard')}
```
state
'use client'import{ useActionState }from'react'import{ createUser }from'@/app/actions'constinitialState={message:'',}exportfunctionSignup() {const[state,formAction,pending]=useActionState(createUser,initialState)return(<formaction={formAction}><labelhtmlFor="email">Email</label><inputtype="text"id="email"name="email"required/>{/* ... */}<paria-live="polite">{state?.message}</p><buttondisabled={pending}>Sign up</button></form>)} ### Pending states ```
pending
useFormStatus
'use client'import{ useFormStatus }from'react-dom'exportfunctionSubmitButton() {const{pending}=useFormStatus()return(<buttondisabled={pending}type="submit">Sign Up</button>)}
```You can then nest theSubmitButtoncomponent inside the form: ```
SubmitButton
import{ SubmitButton }from'./button'import{ createUser }from'@/app/actions'exportfunctionSignup() {return(<formaction={createUser}>{/* Other form elements */}<SubmitButton/></form>)}
```
useOptimistic
'use client'import{ useOptimistic }from'react'import{ send }from'./actions'typeMessage={message:string}exportfunctionThread({ messages }:{ messages:Message[] }) {const[optimisticMessages,addOptimisticMessage]=useOptimistic<Message[],string>(messages,(state,newMessage)=>[...state,{ message:newMessage }])constformAction=async(formData:FormData)=>{constmessage=formData.get('message')asstringaddOptimisticMessage(message)awaitsend(message)}return(<div>{optimisticMessages.map((m,i)=>(<divkey={i}>{m.message}</div>))}<formaction={formAction}><inputtype="text"name="message"/><buttontype="submit">Send</button></form></div>)} ### Event handlers While it's common to use Server Actions within<form>elements, they can also be invoked with event handlers such asonClick. For example, to increment a like count: ```
onClick
'use client'import{ incrementLike }from'./actions'import{ useState }from'react'exportdefaultfunctionLikeButton({ initialLikes }:{ initialLikes:number}) {const[likes,setLikes]=useState(initialLikes)return(<><p>Total Likes: {likes}</p><buttononClick={async()=>{constupdatedLikes=awaitincrementLike()setLikes(updatedLikes)}}>Like</button></>)}
```You can also add event handlers to form elements, for example, to save a form fieldonChange: ```
onChange
'use client'import{ publishPost,saveDraft }from'./actions'exportdefaultfunctionEditPost() {return(<formaction={publishPost}><textareaname="content"onChange={async(e)=>{awaitsaveDraft(e.target.value)}}/><buttontype="submit">Publish</button></form>)}
```
'use client'import{ incrementViews }from'./actions'import{ useState,useEffect }from'react'exportdefaultfunctionViewCount({ initialViews }:{ initialViews:number}) {const[views,setViews]=useState(initialViews)useEffect(()=>{constupdateViews=async()=>{constupdatedViews=awaitincrementViews()setViews(updatedViews)}updateViews()},[])return<p>Total Views: {views}</p>}
```Remember to consider thebehavior and caveatsofuseEffect. ### Error Handling When an error is thrown, it'll be caught by the nearesterror.jsor<Suspense>boundary on the client. SeeError Handlingfor more information. ```
error.js
<Suspense>
```
revalidatePath
'use server'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost() {try{// ...}catch(error) {// ...}revalidatePath('/posts')}
```Or invalidate a specific data fetch with a cache tag usingrevalidateTag: ```
revalidateTag
'use server'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost() {try{// ...}catch(error) {// ...}revalidateTag('posts')} ### Redirecting If you would like to redirect the user to a different route after the completion of a Server Action, you can useredirectAPI.redirectneeds to be called outside of thetry/catchblock: ```
redirect
try/catch
'use server'import{ redirect }from'next/navigation'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost(id:string) {try{// ...}catch(error) {// ...}revalidateTag('posts')// Update cached postsredirect(`/post/${id}`)// Navigate to the new post page} ### Cookies You canget,set, anddeletecookies inside a Server Action using thecookiesAPI: ```
get
set
delete
cookies
'use server'import{ cookies }from'next/headers'exportasyncfunctionexampleAction() {constcookieStore=awaitcookies()// Get cookiecookieStore.get('name')?.value// Set cookiecookieStore.set('name','Delba')// Delete cookiecookieStore.delete('name')}
```
and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it’s still publicly accessible. • Dead code elimination:Unused Server Actions (referenced by their IDs) are removed from client bundle to avoid public access by third-party. The IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated.
This security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints. ```
// app/actions.js'use server'// This action is used in our application, so Next.js// will create a secure ID to allow the client to reference// and call the Server Action.exportasyncfunctionupdateUserAction(formData) {}// This action is not used in our application, so Next.js// will automatically remove this code during `next build`// and will not create a public endpoint.exportasyncfunctiondeleteUserAction(formData) {} ### Authentication and authorization You should ensure that the user is authorized to perform the action. For example: ```
'use server'import{ auth }from'./lib'exportfunctionaddItem() {const{user}=auth()if(!user) {thrownewError('You must be signed in to perform this action')}// ...} ### Closures and encryption Defining a Server Action inside a component creates aclosurewhere the action has access to the outer function's scope. For example, thepublishaction has access to thepublishVersionvariable: ```
publish
publishVersion
exportdefaultasyncfunctionPage() {constpublishVersion=awaitgetLatestVersion();asyncfunctionpublish() {"use server";if(publishVersion!==awaitgetLatestVersion()) {thrownewError('The version has changed since pressing publish');}...}return(<form><buttonformAction={publish}>Publish</button></form>);}
```Closures are useful when you need to capture asnapshotof data (e.g.publishVersion) at the time of rendering so that it can be used later when the action is invoked. Good to know:We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use theReact taint APIsto proactively prevent specific data from being sent to the client. ### Overwriting encryption keys (advanced) ```
process.env.NEXTSERVERACTIONSENCRYPTIONKEY
```
X-Forwarded-Host
```For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration optionserverActions.allowedOriginsoption to specify a list of safe origins. The option accepts an array of strings. ```
serverActions.allowedOrigins
/**@type{import('next').NextConfig}*/module.exports={experimental:{serverActions:{allowedOrigins:['my-proxy.com','*.my-proxy.com'],},},}
```
================================================================================

================================================================================

# App Router: Setting Up Your Database | Next.js
URL: https://nextjs.org/learn/dashboard-app/setting-up-your-database
Section: 2/2
Description: Setup a database for your application and seed it with initial data.
Category: Dashboard App
Document Structure:
- Deploy
- ShowcaseDocsBlogTemplatesEnterprise
Content:
6 Chapter6 # Setting Up Your Database Before you can continue working on your dashboard, you'll need some data. In this chapter, you'll be setting up a PostgreSQL database from one ofVercel's marketplace integrations. If you're already familiar with PostgreSQL and would prefer to use your own database provider, you can skip this chapter and set it up on your own. Otherwise, let's continue! In this chapter... Here are the topics we’ll cover Push your project to GitHub. Set up a Vercel account and link your GitHub repo for instant previews and deployments. Create and link your project to a Postgres database. Seed the database with initial data. ## Create a GitHub repository To start, let's push your repository to GitHub if you haven't already. This will make it easier to set up your database and deploy. If you need help setting up your repository, take a look atthis guide on GitHub. Good to know: • You can also use other git providers like GitLab or Bitbucket.
• If you're new to GitHub, we recommend theGitHub Desktop Appfor a simplified development workflow. ## Create a Vercel account Visitvercel.com/signupto create an account. Choose the free "hobby" plan. SelectContinue with GitHubto connect your GitHub and Vercel accounts. ## Connect and deploy your project Name your project and clickDeploy. Hooray! 🎉
Your project is now deployed. By connecting your GitHub repository, whenever you push changes to yourmainbranch, Vercel will automatically redeploy your application with no configuration needed. When opening pull requests, you'll also haveinstant preview URLswhich allow you to catch deployment errors early and share a preview of your project with team members for feedback. ## Create a Postgres database Choose your region and storage plan, if required. Thedefault regionfor all Vercel projects isWashington D.C (iad1), and we recommend choosing this if available to reducelatencyfor data requests. ```
.env.local
.env.example
.env
```Important:Go to your.gitignorefile and make sure.envis in the ignored files to prevent your database secrets from being exposed when you push to GitHub. ```
.gitignore ## Seed your database Now that your database has been created, let's seed it with some initial data. We've included an API you can access in the browser, which will run a seed script to populate the database with an initial set of data. The script usesSQLto create the tables, and the data fromplaceholder-data.tsfile to populate them after they've been created. ```
placeholder-data.ts
```
pnpm run dev
localhost:3000/seed
```Troubleshooting: • Make sure to reveal your database secrets before copying it into your.envfile.
• The script usesbcryptto hash the user's password, ifbcryptisn't compatible with your environment, you can update the script to usebcryptjsinstead. ```
bcrypt
bcryptjs
DROP TABLE tablename ## Executing queries Let's execute a query to make sure everything is working as expected. We'll use another Router Handler,app/query/route.ts, to query the database. Inside this file, you'll find alistInvoices()function that has the following SQL query. ```
app/query/route.ts
listInvoices()
SELECTinvoices.amount, customers.nameFROMinvoicesJOINcustomersONinvoices.customer_id=customers.idWHEREinvoices.amount=666;
```
Response.json() block
localhost:3000/query
amount
name ## You've Completed Chapter6 With your database now set up and integrated, you can continue building your application. 7: Fetching Data Let's discuss the different ways you can fetch data from your database, including using APIs, SQL, and alternatives.
================================================================================

================================================================================

# App Router: Getting Started | Next.js
URL: https://nextjs.org/learn/dashboard-app/getting-started
Section: 2/2
Description: Create a new Next.js application using the dashboard starter example and explore the project.
Category: Dashboard App
Document Structure:
- Deploy
- ShowcaseDocsBlogTemplatesEnterprise
Content:
1 Chapter1 # Getting Started ## Creating a new project We recommend usingpnpmas your package manager, as it's faster and more efficient thannpmoryarn. If you don't havepnpminstalled, you can install it globally by running: ```
pnpm
npm
yarn
npminstall-gpnpm
cd
npxcreate-next-app@latestnextjs-dashboard--example"https://github.com/vercel/next-learn/tree/main/dashboard/starter-example"--use-pnpm
create-next-app
--example ## Exploring the project Unlike tutorials that have you write code from scratch, much of the code for this course is already written for you. This better reflects real-world development, where you'll likely be working with existing codebases. ```
nextjs-dashboard
cdnextjs-dashboard
```Let's spend some time exploring the project. ### Folder structure You'll notice that the project has the following folder structure: • /app: Contains all the routes, components, and logic for your application, this is where you'll be mostly working from.
• /app/lib: Contains functions used in your application, such as reusable utility functions and data fetching functions.
• /app/ui: Contains all the UI components for your application, such as cards, tables, and forms. To save time, we've pre-styled these components for you.
• /public: Contains all the static assets for your application, such as images. ```
/app
/app/lib
/app/ui
/public
next.config.ts
```
• Use a 3rd party service likemockAPI. For this project, we've provided some placeholder data inapp/lib/placeholder-data.ts. Each JavaScript object in the file represents a table in your database. For example, for the invoices table: ```
app/lib/placeholder-data.ts
constinvoices=[{customerid:customers[0].id,amount:15795,status:'pending',date:'2022-12-06',},{customerid:customers[1].id,amount:20348,status:'pending',date:'2022-11-14',},// ...];
```In the chapter onsetting up your database, you'll use this data toseedyour database (populate it with some initial data). ### TypeScript You may also notice most files have a.tsor.tsxsuffix. This is because the project is written in TypeScript. We wanted to create a course that reflects the modern web landscape. ```
.ts
.tsx
```
/app/lib/definitions.ts
exporttypeInvoice={id:string;customer_id:string;amount:number;date:string;// In TypeScript, this is called a string union type.// It means that the "status" property can only be one of the two strings: 'pending' or 'paid'.status:'pending'|'paid';};
```By using TypeScript, you can ensure you don't accidentally pass the wrong data format to your components or database, like passing astringinstead of anumberto invoiceamount. ```
string
number
amount
```
pnpm i
pnpmi
```Followed bypnpm devto start the development server. ```
pnpm dev
pnpmdev
3000
```
================================================================================

================================================================================

# eslint ```
next build
next.config.js
ignoreDuringBuilds
module.exports={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},}
================================================================================

================================================================================

# Getting Started ### Installation ### Project Structure ### Layouts and Pages ### Images and Fonts ### CSS ### Fetching Data ### Updating Data ### Error Handling ### Metadata and OG images ### Deploying ### Upgrading
================================================================================

================================================================================

# create-next-app Basic usage: ```
npxcreate-next-app@latest[project-name] [options] ## Reference The following options are available: Options | Description
-hor--help | Show all available options
-vor--version | Output the version number
--no-* | Negate default options. E.g.--no-eslint
--tsor--typescript | Initialize as a TypeScript project (default)
--jsor--javascript | Initialize as a JavaScript project
--tailwind | Initialize with Tailwind CSS config (default)
--eslint | Initialize with ESLint config
--app | Initialize as an App Router project
--api | Initialize a project with only route handlers
--src-dir | Initialize inside asrc/directory
--turbopack | Enable Turbopack by default for development
--import-alias <alias-to-configure> | Specify import alias to use (default "@/*")
--empty | Initialize an empty project
--use-npm | Explicitly tell the CLI to bootstrap the application using npm
--use-pnpm | Explicitly tell the CLI to bootstrap the application using pnpm
--use-yarn | Explicitly tell the CLI to bootstrap the application using Yarn
--use-bun | Explicitly tell the CLI to bootstrap the application using Bun
-eor--example [name] [github-url] | An example to bootstrap the app with
--example-path <path-to-example> | Specify the path to the example separately
--reset-preferences | Explicitly tell the CLI to reset any stored preferences
--skip-install | Explicitly tell the CLI to skip installing packages
--yes | Use previous preferences or defaults for all options ```
-h
--help
-v
--version
--no-*
--no-eslint
--ts
--typescript
--js
--javascript
--tailwind
--eslint
--app
--api
--src-dir
src/
--turbopack
--import-alias <alias-to-configure>
--empty
--use-npm
--use-pnpm
--use-yarn
--use-bun
-e
--example [name] [github-url]
--example-path <path-to-example>
--reset-preferences
--skip-install
--yes ## Examples ### With the default template To create a new app using the default template, run the following command in your terminal: ```
npxcreate-next-app@latest
```You will then be asked the following prompts: ```
What is your project named? my-appWould you like to use TypeScript? No / YesWould you like to use ESLint? No / YesWould you like to use Tailwind CSS? No / YesWould you like your code inside a `src/` directory? No / YesWould you like to use App Router? (recommended) No / YesWould you like to use Turbopack for `next dev`? No / YesWould you like to customize the import alias (`@/*` by default)? No / Yes
```
--example
npxcreate-next-app@latest--example[example-name] [your-project-name] ### With any public GitHub example To create a new app using any public GitHub example, use the--exampleoption with the GitHub repo's URL. For example: ```
npxcreate-next-app@latest--example"https://github.com/.../"[your-project-name]
================================================================================

================================================================================

# typescript ```
next build

================================================================================

# src Directory ```
app
pages
src
```This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams. To use thesrcdirectory, move theappRouter folder orpagesRouter folder tosrc/apporsrc/pagesrespectively. ```
src/app
src/pages
```
• Config files likepackage.json,next.config.jsandtsconfig.jsonshould remain in the root of your project.
• .env.*files should remain in the root of your project.
• src/apporsrc/pageswill be ignored ifapporpagesare present in the root directory.
• If you're usingsrc, you'll probably also move other application folders such as/componentsor/lib.
• If you're using Middleware, ensure it is placed inside thesrcdirectory.
• If you're using Tailwind CSS, you'll need to add the/srcprefix to thetailwind.config.jsfile in thecontent section.
• If you are using TypeScript paths for imports such as@/*, you should update thepathsobject intsconfig.jsonto includesrc/. ```
/public
package.json
next.config.js
tsconfig.json
.env.*
/components
/lib
/src
tailwind.config.js
paths
src/ ## Next Steps ### Project Structure
================================================================================

================================================================================

# Runtimes • TheNode.js Runtime(default), which has access to all Node.js APIs and compatible packages from the ecosystem.
• TheEdge Runtimewhich contains a more limitedset of APIs. The Edge Runtime is the default runtime forMiddleware. However, this can be changed to the Node.js runtime. See theMiddleware documentationfor more details. ## Use Cases • The Node.js Runtime is used for rendering your application.
• The Edge Runtime is used for Middleware (routing rules like redirects, rewrites, and setting headers). ## Caveats • The Edge Runtime does not support all Node.js APIs. Some packages may not work as expected. Learn more about the unsupported APIs in theEdge Runtime.
• The Edge Runtime does not support Incremental Static Regeneration (ISR).
• Both runtimes can supportstreamingdepending on your deployment infrastructure. ## Next Steps ### Edge Runtime
================================================================================

================================================================================

# Client Components Client Components allow you to write interactive UI that isprerendered on the serverand can use client JavaScript to run in the browser. This page will go through how Client Components work, how they're rendered, and when you might use them. ## Benefits of Client Rendering There are a couple of benefits to doing the rendering work on the client, including: • Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.
• Browser APIs: Client Components have access to browser APIs, likegeolocationorlocalStorage. ## Using Client Components in Next.js To use Client Components, you can add the React"use client"directiveat the top of a file, above your imports. ```
"use client"
```"use client"is used to declare aboundarybetween a Server and Client Component modules. This means that by defining a"use client"in a file, all other modules imported into it, including child components, are considered part of the client bundle. ```
'use client'import{ useState }from'react'exportdefaultfunctionCounter() {const[count,setCount]=useState(0)return(<div><p>You clicked {count} times</p><buttononClick={()=>setCount(count+1)}>Click me</button></div>)}
onClick
useState
toggle.js
```
use client

================================================================================

# Server Components • Static Rendering
• Dynamic Rendering
• Streaming This page will go through how Server Components work, when you might use them, and the different server rendering strategies. ## Benefits of Server Rendering There are a couple of benefits to doing the rendering work on the server, including: • Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client. ## Using Server Components in Next.js ## How are Server Components rendered? Each chunk is rendered in two steps: • React renders Server Components into a special data format called theReact Server Component Payload (RSC Payload).
• Next.js uses the RSC Payload and Client Component JavaScript instructions to renderHTMLon the server. Then, on the client: • The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.
• The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.
• The JavaScript instructions are used tohydrateClient Components and make the application interactive. #### What is the React Server Component Payload (RSC)? The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains: • The rendered result of Server Components
• Placeholders for where Client Components should be rendered and references to their JavaScript files
• Any props passed from a Server Component to a Client Component ## Server Rendering Strategies There are three subsets of server rendering: Static, Dynamic, and Streaming. ### Static Rendering (Default) With Static Rendering, routes are rendered atbuild time, or in the background afterdata revalidation. The result is cached and can be pushed to aContent Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests. Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page. With Dynamic Rendering, routes are rendered for each user atrequest time. Dynamic Routes with Cached Data In most websites, routes are not fully static or fully dynamic - it's a spectrum. For example, you can have an e-commerce page that uses cached product data that's revalidated at an interval, but also has uncached, personalized customer data. Learn more about thefull-route cacheandData Cache. #### Switching to Dynamic Rendering ```
{ cache: 'no-store' }

================================================================================

# Server and Client Composition Patterns When building React applications, you will need to consider what parts of your application should be rendered on the server or the client. This page covers some recommended composition patterns when using Server and Client Components. ## When to use Server and Client Components? Here's a quick summary of the different use cases for Server and Client Components: What do you need to do? | Server Component | Client Component
Fetch data | | Access backend resources (directly) | | Keep sensitive information on the server (access tokens, API keys, etc) | | Keep large dependencies on the server / Reduce client-side JavaScript | | Add interactivity and event listeners (onClick(),onChange(), etc) | | Use State and Lifecycle Effects (useState(),useReducer(),useEffect(), etc) | | Use browser-only APIs | | Use custom hooks that depend on state, effects, or browser-only APIs | | UseReact Class components | | ```
onClick()
onChange()
useState()
useReducer()
useEffect() ## Server Component Patterns Before opting into client-side rendering, you may wish to do some work on the server like fetching data, or accessing your database or backend services. Here are some common patterns when working with Server Components: ### Sharing data between components When fetching data on the server, there may be cases where you need to share data across different components. For example, you may have a layout and a page that depend on the same data. Instead of usingReact Context(which is not available on the server) or passing data as props, you can usefetchor React'scachefunction to fetch the same data in the components that need it, without worrying about making duplicate requests for the same data. This is because React extendsfetchto automatically memoize data requests, and thecachefunction can be used whenfetchis not available. ```
fetch
cache
```View an exampleof this pattern. ### Keeping Server-only Code out of the Client Environment Since JavaScript modules can be shared between both Server and Client Components modules, it's possible for code that was only ever intended to be run on the server to sneak its way into the client. For example, take the following data-fetching function: ```
exportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.APIKEY,},})returnres.json()}
```
getData
APIKEY
NEXTPUBLIC
```As a result, even thoughgetData()can be imported and executed on the client, it won't work as expected. And while making the variable public would make the function work on the client, you may not want to expose sensitive information to the client. ```
getData()
```
server-only
```To useserver-only, first install the package: ```
npminstallserver-only
```
import'server-only'exportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}
```Now, any Client Component that importsgetData()will receive a build-time error explaining that this module can only be used on the server. The corresponding packageclient-onlycan be used to mark modules that contain client-only code – for example, code that accesses thewindowobject. ```
client-only
window ### Using Third-party Packages and Providers Since Server Components are a new React feature, third-party packages and providers in the ecosystem are just beginning to add the"use client"directive to components that use client-only features likeuseState,useEffect, andcreateContext. ```
"use client"
useState
useEffect
createContext
```
npm
```For example, let's say you've installed the hypotheticalacme-carouselpackage which has a<Carousel />component. This component usesuseState, but it doesn't yet have the"use client"directive. ```
acme-carousel
<Carousel />
```
'use client'import{ useState }from'react'import{ Carousel }from'acme-carousel'exportdefaultfunctionGallery() {const[isOpen,setIsOpen]=useState(false)return(<div><buttononClick={()=>setIsOpen(true)}>View pictures</button>{/* Works, since Carousel is used within a Client Component */}{isOpen&&<Carousel/>}</div>)}
```However, if you try to use it directly within a Server Component, you'll see an error: ```
import{ Carousel }from'acme-carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/* Error: `useState` can not be used within Server Components */}<Carousel/></div>)}
```
'use client'import{ Carousel }from'acme-carousel'exportdefaultCarousel
```Now, you can use<Carousel />directly within a Server Component: ```
importCarouselfrom'./carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/* Works, since Carousel is a Client Component */}<Carousel/></div>)}
```
import{ createContext }from'react'// createContext is not supported in Server ComponentsexportconstThemeContext=createContext({})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeContext.Providervalue="dark">{children}</ThemeContext.Provider></body></html>)}
```To fix this, create your context and render its provider inside of a Client Component: ```
'use client'import{ createContext }from'react'exportconstThemeContext=createContext({})exportdefaultfunctionThemeProvider({children,}:{children:React.ReactNode}) {return<ThemeContext.Providervalue="dark">{children}</ThemeContext.Provider>}
```
importThemeProviderfrom'./theme-provider'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeProvider>{children}</ThemeProvider></body></html>)}
```With the provider rendered at the root, all other Client Components throughout your app will be able to consume this context. ```
ThemeProvider
{children}
<html> #### Advice for Library Authors In a similar fashion, library authors creating packages to be consumed by other developers can use the"use client"directive to mark client entry points of their package. This allows users of the package to import package components directly into their Server Components without having to create a wrapping boundary. You can optimize your package by using'use client' deeper in the tree, allowing the imported modules to be part of the Server Component module graph. It's worth noting some bundlers might strip out"use client"directives. You can find an example of how to configure esbuild to include the"use client"directive in theReact Wrap BalancerandVercel Analyticsrepositories. ## Client Components ### Moving Client Components Down the Tree To reduce the Client JavaScript bundle size, we recommend moving Client Components down your component tree. ```
<SearchBar />
// SearchBar is a Client ComponentimportSearchBarfrom'./searchbar'// Logo is a Server ComponentimportLogofrom'./logo'// Layout is a Server Component by defaultexportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Logo/><SearchBar/></nav><main>{children}</main></>)} ### Passing props from Server to Client Components (Serialization) If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to beserializableby React. If your Client Components depend on data that isnotserializable, you canfetch data on the client with a third party libraryor on the server with aRoute Handler. ## Interleaving Server and Client Components When interleaving Client and Server Components, it may be helpful to visualize your UI as a tree of components. Starting with theroot layout, which is a Server Component, you can then render certain subtrees of components on the client by adding the"use client"directive. Within those client subtrees, you can still nest Server Components or call Server Actions, however there are some things to keep in mind: ```
props ### Unsupported Pattern: Importing Server Components into Client Components The following pattern is not supported. You cannot import a Server Component into a Client Component: ```
'use client'// You cannot import a Server Component into a Client Component.importServerComponentfrom'./Server-Component'exportdefaultfunctionClientComponent({children,}:{children:React.ReactNode}) {const[count,setCount]=useState(0)return(<><buttononClick={()=>setCount(count+1)}>{count}</button><ServerComponent/></>)} ### Supported Pattern: Passing Server Components to Client Components as Props The following pattern is supported. You can pass Server Components as a prop to a Client Component. A common pattern is to use the Reactchildrenprop to create a"slot"in your Client Component. ```
children
```
<ClientComponent>
'use client'import{ useState }from'react'exportdefaultfunctionClientComponent({children,}:{children:React.ReactNode}) {const[count,setCount]=useState(0)return(<><buttononClick={()=>setCount(count+1)}>{count}</button>{children}</>)}
```<ClientComponent>doesn't know thatchildrenwill eventually be filled in by the result of a Server Component. The only responsibility<ClientComponent>has is to decidewherechildrenwill eventually be placed. In a parent Server Component, you can import both the<ClientComponent>and<ServerComponent>and pass<ServerComponent>as a child of<ClientComponent>: ```
<ServerComponent>
// This pattern works:// You can pass a Server Component as a child or prop of a// Client Component.importClientComponentfrom'./client-component'importServerComponentfrom'./server-component'// Pages in Next.js are Server Components by defaultexportdefaultfunctionPage() {return(<ClientComponent><ServerComponent/></ClientComponent>)}
```
• You're not limited to thechildrenprop. You can use any prop to pass JSX.
================================================================================

================================================================================

# Partial Prerendering Note:Partial Prerendering is anexperimentalfeature only available on canary and is subject to change. It is not ready for production use. Partial Prerendering (PPR) enables you to combine static and dynamic components together in the same route. 🎥 Watch:Why PPR and how it works YouTube (10 minutes). ## Background To prevent client to server waterfalls, dynamic components begin streaming from the server in parallel while serving the initial prerender. This ensures dynamic components can begin rendering before client JavaScript has been loaded in the browser. To prevent creating many HTTP requests for each dynamic component, PPR is able to combine the static prerender and dynamic components together into a single HTTP request. This ensures there are not multiple network roundtrips needed for each dynamic component. ## Using Partial Prerendering ### Incremental Adoption (Version 15 Canary Versions) ```
npminstallnext@canary
ppr
next.config.js
incremental
experimentalppr
importtype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{ppr:'incremental',},}exportdefaultnextConfig
import{ Suspense }from'react'import{ StaticComponent,DynamicComponent,Fallback }from'@/app/ui'exportconstexperimentalppr=trueexportdefaultfunctionPage() {return(<><StaticComponent/><Suspensefallback={<Fallback/>}><DynamicComponent/></Suspense></>)}
```Good to know: • Routes that don't haveexperimentalpprwill default tofalseand will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.
• experimentalpprwill apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.
• To disable PPR for children segments, you can setexperimentalpprtofalsein the child segment. ```
false ## Dynamic Components ```
next build
fallback
```
cookies
headers
import{ cookies }from'next/headers'exportasyncfunctionUser() {constsession=(awaitcookies()).get('session')?.valuereturn'...'}
```This component requires looking at the incoming request to read cookies. To use this with PPR, you should wrap the component with Suspense: ```
import{ Suspense }from'react'import{ User,AvatarSkeleton }from'./user'exportconstexperimentalppr=trueexportdefaultfunctionPage() {return(<section><h1>This will be prerendered</h1><Suspensefallback={<AvatarSkeleton/>}><User/></Suspense></section>)}
```
searchParams
page
import{ Table }from'./table'exportdefaultfunctionPage({searchParams,}:{searchParams:Promise<{ sort:string}>}) {return(<section><h1>This will be prerendered</h1><TablesearchParams={searchParams} /></section>)}
exportasyncfunctionTable({searchParams,}:{searchParams:Promise<{ sort:string}>}) {constsort=(awaitsearchParams).sort==='true'return'...'}
================================================================================

================================================================================

